{    ClearSVec(Vortho^);
    NVec := DVecToSVec(NormaliseVector(Vin));
    if Abs(NVec[0]) > 0.1 then
    begin
      Vortho^[0] := NVec[2];
      Vortho^[2] := -NVec[0];
    end else begin
      Vortho^[1] := -NVec[2];
      Vortho^[2] := NVec[1];
    end;
    NormaliseSVectorVar(Vortho^);
    TPLightSD(Vortho)^[1] := SVectorCross(Vortho^, NVec);
}

{var d: Double;
begin
    if PIt3D.Rout <= 1 then
      PIt3D.SmoothItD := PIt3D.ItResultI
    else if PIt3D.Rold < 1 then
      PIt3D.SmoothItD := PIt3D.ItResultI + PIt3D.LNRStop - Ln(0.5 * Ln(PIt3D.Rout)) * PIt3D.fHln[n]
    else
    begin
      d := Ln(0.5 * Ln(PIt3D.Rout));
      PIt3D.SmoothItD := PIt3D.ItResultI + (PIt3D.LNRStop - d) / (d - Ln(0.5 * Ln(PIt3D.Rold)));
    end; // }


{procedure HybridItTricorn(var x, y, z, w: Double; PIteration3D: TPIteration3D);
var xt: Double;
begin
    with PIteration3D^ do
    begin
      xt := x;
      x  := x * x - y * y - z * z + J1;
      y  := 2 * xt * y + J2;
      z  := dOption1 * xt * z + J3;    
    end;
end;}

{var th, ph, pp: Double;
    Esin1, Ecos1, Esin2, Ecos2: Double;
begin
    with PIteration3D^ do
    begin
  //    R  := Sqrt(Rout);
      th := ArcTan2(y, x);
      ph := ArcTan2(z, Sqrt(Sqr(x) + Sqr(y)));   //  ArcSin(z / R);
      pp := Power(Rout, 0.5 * PDouble(Integer(PVar) - 16)^);
      SinCosD(PDouble(Integer(PVar) - 16)^ * ph, Esin1, Ecos1);
      SinCosD(PDouble(Integer(PVar) - 16)^ * th, Esin2, Ecos2);
      x := pp * Ecos1 * Ecos2 + J1;
      y := pp * Ecos1 * Esin2 + J2;
      z := PDouble(Integer(PVar) - 24)^ * pp * Esin1 + J3;
    end;  }
    
    {var R, A, yt: Double;
    begin
        with PIteration3D^ do
        begin
          R  := x * x + y * y;
          yt := y;
          A := 1 + (sz * (sz - 6 * R)) / (R * R + d1em40);
          y := 4 * x * y * A * (sx - sy) + J2;                      //4: PVars + 128
          z := PDouble(Integer(PVar) - 16)^ * 4 * Sqrt(R) * z * (R - sz) + J3;  //6: PVars + 144
          x := A * (sx * (sx - 6 * sy) + sy * sy) + J1;
    end;  }
    
    {var sx, sy, sz, A, R: Double;
    begin
      with PIteration3D^ do
      begin
        sx := x*x;
        sy := y*y;
        R  := sx + sy;
        sz := z*z;
        A  := 1 + 5*(sz*sz - 2*R*sz) / (R*R + d1em40);
        y  := A*y*(5*sx*sx - sy*(10*sx - sy)) + J2;
        z  := PDouble(Integer(PVar) - 16)^*z*(sz*(sz - 10*R) + 5*R*R) + J3;
        x  := A*x*(sx*(sx - 10*sy) + 5*sy*sy) + J1;
  end;  }
 
 {var S1, S2, sz, A, R: Double;
  begin
    with PIteration3D^ do
    begin
      S1 := x*x;
      S2 := y*y;
      R  := S1 + S2;
      sz := z*z;
      A  := 1 - (sz*(sz*(sz - 15*R) + 15*R*R)) / (R*R*R + d1em40);
      y  := 2*A*x*y*(S1*(3*S1 - 10*S2) + 3*S2*S2) + J2;
      z  := PDouble(Integer(PVar) - 16)^*2*z*Sqrt(R)*(sz*(3*sz - 10*R) + 3*R*R) + J3;
      x  := A*(S1*S1*(S1 - 15*S2) + S2*S2*(15*S1 - S2)) + J1;
  end; }

{var S1, S2, S3, A, R: Double;
begin
  with PIteration3D^ do
  begin
    S1 := x*x;
    S2 := y*y;
    R  := S1 + S2;
    S3 := z*z;
    A  := 1 - 7*(S3*(S3*(S3 - 5*R) + 3*R*R)) / (R*R*R + d1em40);
    y  := A*y*(S1*(S1*(7*S1 - 35*S2) + 21*S2*S2) - S2*S2*S2) + J2;
    z  := J3 - PDouble(Integer(PVar) - 16)^* (z*S3*S3*S3 - 7*z*R*(S3*(3*S3 - 5*R) + R*R) );
    x  := A*x*(S1*(S1*(S1 - 21*S2) + 35*S2*S2) - 7*S2*S2*S2) + J1;
  end;  }

{asm
    push esi  // SinY with index, preoffset, prescale, scale, offset
    push edi
    mov  esi, [ebp + 8]
    mov  edi, [esi + 48]
    mov  esi, [edi - 12]
    and  esi, 3
    fld  qword [eax + esi * 8]
    fsub dword [edi - 16]
    fmul dword [edi - 20]
    fsin
    fmul dword [edi - 24]
    fadd dword [edi - 28]
    fstp qword [eax + esi * 8]
    pop  edi
    pop  esi    }

 {   push esi   // kalisets
    push edi
    mov  esi, [ebp + 8]
    mov  edi, [esi + 48]
    fld  qword [eax]
    fabs
    fld  qword [edx]
    fabs
    fld  qword [ecx]
    fabs
    fld  st(2)
    fmul st, st
    fld  st(2)
    fmul st, st
    faddp
    fld  st(1)
    fmul st, st
    faddp
    fadd qword [edi - 24]
    fld  qword [edi - 16]
    fdivrp
    fmul st(3), st
    fmul st(2), st
    fmul st(1), st
    fmul qword [ecx + 8]
    fstp qword [ecx + 8]
    fadd qword [esi + $28]
    fstp qword [ecx]
    fadd qword [esi + $20]
    fstp qword [edx]
    fadd qword [esi + $18]
    fstp qword [eax]
    pop  edi
    pop  esi  }
    
    
    

  {    testIFSOptionTypes: array [0..9] of Integer = (0,0,0,0,0,2,2,1,1,2);
       testIFSOptionVals: array [0..9] of Double = (0,1,0,0,1,0,0,0,1,0);
       testIFSOptionsStrings: array [0..9] of String = ('Normal Z','Normal Y','Normal X','Offset','Scale',
         'Otrap color map','Map channel','Otrap offset','Otrap scale', 'Solid (0,1)');
       testIFSOptionsStrings: array [0..7] of String = ('Normal Z','Normal Y','Normal X','Offset','Scale',
                                                          -16        -24        -32        -40     -48
         'Otrap color map','Map channel','Otrap offset','Otrap scale', 'Solid(0|1)');
              -52               -56           -60             -64        -68}

{
  //IFS formula, rounded Box with otrap coloring modes
  movupd xmm0, [esi - 120]  //x,y
  movsd  xmm1, [esi - 104]  //z
  mulpd  xmm0, [edi - 48]   //*Scale
  mulsd  xmm1, [edi - 48]
  addpd  xmm0, [edi - 80]   //+translate
  addsd  xmm1, [edi - 64]
  xorpd  xmm4, xmm4
  cmp    [edi - 100], 0
  je @@1
  movsd  xmm5, [esi + 112]  //accumulated scale
  mulsd  xmm5, [edi - 48]
  movupd [esi - 120], xmm0
  movsd  [esi - 104], xmm1
  movsd  [esi + 112], xmm5
@@1:
  andpd  xmm0, [edi]        // abs=and [$7FFFFFFF,$7FFFFFFF]
  andpd  xmm1, [edi]
  subpd  xmm0, [edi - 32]
  subsd  xmm1, [edi - 16]
  addpd  xmm0, [edi - 96]
  addsd  xmm1, [edi - 96]
  maxpd  xmm0, xmm4
  maxsd  xmm1, xmm4
  mulpd  xmm0, xmm0
  mulsd  xmm1, xmm1
  addsd  xmm1, xmm0
  shufpd xmm0, xmm0, 1
  addsd  xmm1, xmm0
  sqrtsd xmm1, xmm1
  subsd  xmm1, [edi - 96]
  cmp    [edi - 100], 0
  jne @@2
  divsd  xmm1, [edi - 48]
@@2:
  mov eax, [edi - 104]
  movsd  [esi - 32], xmm1   //Rout: Double;     //+56
  and eax, 3
  fld  qword [esi + eax * 8 - 128]
  fmul dword [edi - 112]
  fadd dword [edi - 108]
  fstp qword [esi + 128]


      //IFS formula, cylinder with scale + radius + barrel + tip, SSE2  +OTrap  +inside radius
{  movupd xmm0, [esi - 112]  //y,z
  movsd  xmm1, [esi - 120]  //x
  mulpd  xmm0, [edi - 48]   //*Scale
  mulsd  xmm1, [edi - 48]
  addpd  xmm0, [edi - 64]   //+translate
  addsd  xmm1, [edi - 72]
  cmp    [edi - 92], 0
  je @@1
  movsd  xmm5, [esi + 112]  //accumulated scale +200
  mulsd  xmm5, [edi - 48]
  movupd [esi - 112], xmm0
  movsd  [esi - 120], xmm1
  movsd  [esi + 112], xmm5
@@1:
  movapd xmm4, xmm1
  mulpd  xmm0, xmm0
  andpd  xmm1, [edi]        //abs(x)
  pshufd xmm2, xmm0, $4E
  movapd xmm3, xmm1
  subsd  xmm1, [edi - 32]   //-xhw
  addsd  xmm0, xmm2
  minsd  xmm3, [edi - 32]
  mulsd  xmm4, [edi - 88]   //tip
  mulsd  xmm3, xmm3
  sqrtsd xmm0, xmm0
  movsd  xmm2, [edi - 112]  //Inside radius
  mulsd  xmm3, [edi - 80]   //Barrel
  subsd  xmm2, xmm0
  subsd  xmm0, [edi - 16]   //Radius
  subsd  xmm2, xmm3
  addsd  xmm0, xmm3
  subsd  xmm2, xmm4
  addsd  xmm0, xmm4
  maxsd  xmm0, xmm2
  maxsd  xmm0, xmm1
  cmp    [edi - 92], 0
  jne @@2
  divsd  xmm0, [edi - 48]
@@2:
  mov eax, [edi - 96]
  movsd  [esi - 32], xmm0   //Rout: Double;     //+56
  and eax, 3
  fld  qword [esi + eax * 8 - 128]
  fmul dword [edi - 104]
  fadd dword [edi - 100]
  fstp qword [esi + 128]   }

 {  push  ecx                 // Cylinder heightmap
  add   esp, -32            //  'Map nr', 'Map channel', 'X off', 'Y off', 'Z off',
                            //    -12          -16        -20      -24       -28
                            //  'Length', 'Radius', 'Map height', 'Scale', 'X rot', 'Y rot', 'Z rot',
                            //     -32        -36        -40                -44      ..        -76
                            //  'OTrap channel','OTrap offset', 'OTrap mul'
  fld   qword [esi - 104]   //        -80            -84            -88
  fsub  dword [edi - 28]
  fld   qword [esi - 112]
  fsub  dword [edi - 24]
  fld   qword [esi - 120]   //x,y,z
  fsub  dword [edi - 20]
    fld   st(0)            // rotate+scale   x,y,z
    fmul  dword [edi - 36-32]
    fld   st(2)            //y,cz,x,y,z
    fmul  dword [edi - 40-32]
    faddp                  //cz+cy,x,y,z
    fld   st(3)
    fmul  dword [edi - 44-32]
    faddp                  //nz,x,y,z
    fld   st(1)            //x,nz,x,y,z
    fmul  dword [edi - 12-32]
    fld   st(3)            //y,cx,nz,x,y,z
    fmul  dword [edi - 16-32]
    faddp                  //cx+cy,nz,x,y,z
    fld   st(4)
    fmul  dword [edi - 20-32]
    faddp                  //nx,nz,x,y,z
    fxch  st(2)            //x,nz,nx,y,z
    fmul  dword [edi - 24-32]
    fxch  st(3)            //y,nz,nx,cx,z
    fmul  dword [edi - 28-32]
    faddp st(3), st(0)     //nz,nx,cx+cy,z
    fxch  st(3)            //z,nx,cx+cy,nz
    fmul  dword [edi - 32-32]
    faddp st(2), st(0)     //nx,ny,nz


    fld  st(1)
    fmul st, st
    fld  st(1)
    fmul st, st
    faddp
    fsqrt
    fst  dword [esp + 28]
    fsub dword [edi - 36]  //Rdist,x,y,z
    fld  st(3)
    fabs
    fsub dword [edi - 32]
 //   fst  dword [esp + 28]  //Zdist
    fcom
    fnstsw ax
    shr ah, 1
    jc  @@0
    fxch                   // top/bottom flat without map
@@0:
    fstp  st
           //speedup: map only if distance to surface is less than...
  fld  st                  //r,r,x,y,z
  fabs
  fld  dword [edi - 40]    //Hmul,r',Rdist,x,y,z
  fabs
  fcompp                   //Rdist,x,y,z
  fnstsw ax
  shr  ah, 1
  jnc  @@1
@@2:
    fstp  qword [esi - 32]  //Rout: Double; +56  is distance
    fcompp
    fstp  st
    add   esp, 32
    pop   ecx
    ret
@@1:
//convert x,y to angle
  fstp  dword [esp + 24]    //radius
  fld   st(1)               //y,x,y,z
  fpatan
  fmul  qword [edi]         //0.5/Pi
  fstp  qword [esp]         //y,z
  fstp  st //qword [esp + 8]
      //divide by pi*2 and radius
  fmul  qword [edi]
  fdiv  dword [edi - 36]   //radius
  fstp  qword [esp + 8]
  mov   eax, esp
  mov   edx, [edi - 12]
  mov   ecx, esp
  call  [esi + 268]         //+356 - 88 = 268
//   PMapFunc2:  esi+356    //   eax             edx             ecx
//function GetMapPixelDirectXY(PVec3D: TPVec3D; MapNr: Integer): TVec3D; //Direct pixel coords 0..1 with tiling
//    PMapFunc:   TLMSfunction;//+352   pointer to a map function: function GetMapPixelSphere(PVec3D: TPVec3D; MapNr: Integer): TVec3D;
  //  PMapFunc2:  TLMSfunction;//+356   pointer to 2nd map function, PVec3D: X,Y double used to get direct pixel in range 0..1
  mov   ecx, [edi - 16]
  and   ecx, 3
  fld   qword [esp + ecx * 8]   //col of map
  fsub  qword [edi - 8]
  fmul  dword [edi - 40]    //amplitude H scale
  fmul  dword [esp + 28]    //new, to decrease top/bottom inside
  fsubr dword [esp + 24]
  fstp  qword [esi - 32]    //Rout: Double; +56  is distance
  mov   ecx, [edi - 80]     //Otrap color mapnr
  and   ecx, 3
  fld   qword [esp + ecx * 8]   //col of map
  fadd  dword [edi - 84]
  fmul  dword [edi - 88]
  fstp  qword [esi + 128]   //dfree1 for otrap coloring
  add   esp, 32
  pop   ecx

{     push  ecx                 // sphere heightmap
  add   esp, -32            //  'Map nr', 'Map channel', 'X off', 'Y off', 'Z off',
                            //    -12          -16        -20      -24       -28
                            //  'X scale', 'Y scale', 'H scale', 'Scale', 'X rot', 'Y rot', 'Z rot',
                            //     -32        -36        -40                -44      ..        -76
                            //  'OTrap channel','OTrap offset', 'OTrap mul'
  fld   qword [esi - 104]   //        -80            -84            -88
  fsub  dword [edi - 28]
  fld   qword [esi - 112]
  fmul  dword [edi - 36]
  fsub  dword [edi - 24]
  fld   qword [esi - 120]   //x,y,z
  fmul  dword [edi - 32]
  fsub  dword [edi - 20]
    fld   st(0)            // rotate+scale   x,y,z
    fmul  dword [edi - 36-32]
    fld   st(2)            //y,cz,x,y,z
    fmul  dword [edi - 40-32]
    faddp                  //cz+cy,x,y,z
    fld   st(3)
    fmul  dword [edi - 44-32]
    faddp                  //nz,x,y,z
    fld   st(1)            //x,nz,x,y,z
    fmul  dword [edi - 12-32]
    fld   st(3)            //y,cx,nz,x,y,z
    fmul  dword [edi - 16-32]
    faddp                  //cx+cy,nz,x,y,z
    fld   st(4)
    fmul  dword [edi - 20-32]
    faddp                  //nx,nz,x,y,z
    fxch  st(2)            //x,nz,nx,y,z
    fmul  dword [edi - 24-32]
    fxch  st(3)            //y,nz,nx,cx,z
    fmul  dword [edi - 28-32]
    faddp st(3), st(0)     //nz,nx,cx+cy,z
    fxch  st(3)            //z,nx,cx+cy,nz
    fmul  dword [edi - 32-32]
    faddp st(2), st(0)     //nx,ny,nz

    fld  st(2)
    fmul st, st
    fld  st(2)
    fmul st, st
    faddp
    fld  st(1)
    fmul st, st
    faddp
    fsqrt
    fld1
    fsubp   //Rdist,x,y,z
           //speedup: map only if distance to surface is less than...
  fld  st                  //r,r,x,y,z
  fabs
  fld  dword [edi - 40]    //Hmul,r',Rdist,x,y,z
  fabs
  fcompp                   //Rdist,x,y,z
  fnstsw ax
  shr ah, 1
  jnc @@1
  fstp  qword [esi - 32]    //Rout: Double; +56  is distance
  fcompp
  fstp  st
  add   esp, 32
  pop   ecx
  ret //
@@1:
  fstp  qword [esp + 24]
  fstp  qword [esp]
  fstp  qword [esp + 8]
  fstp  qword [esp + 16]
  mov   eax, esp
  mov   edx, [edi - 12]
  mov   ecx, esp
  call  [esi + 264]         //+356 - 88 = 268
//   PMapFunc2:  esi+356    //   eax             edx             ecx
//function GetMapPixelDirectXY(PVec3D: TPVec3D; MapNr: Integer): TVec3D; //Direct pixel coords 0..1 with tiling
//    PMapFunc:   TLMSfunction;//+352   pointer to a map function: function GetMapPixelSphere(PVec3D: TPVec3D; MapNr: Integer): TVec3D;
  //  PMapFunc2:  TLMSfunction;//+356   pointer to 2nd map function, PVec3D: X,Y double used to get direct pixel in range 0..1
  mov   ecx, [edi - 16]
  and   ecx, 3
  fld   qword [esp + ecx * 8]   //col of map
  fsub  qword [edi - 8]
  fmul  dword [edi - 40]    //amplitude H scale
  fsubr qword [esp + 24]
  fstp  qword [esi - 32]    //Rout: Double; +56  is distance
  mov   ecx, [edi - 80]     //Otrap color mapnr
  and   ecx, 3
  fld   qword [esp + ecx * 8]   //col of map
  fadd  dword [edi - 84]
  fmul  dword [edi - 88]
  fstp  qword [esi + 128]   //dfree1 for otrap coloring
  add   esp, 32
  pop   ecx}

{  push  ecx                 //      added OTrap coloring  + speedup
  add   esp, -32            //      HeightMap  [nr: integer; Xoffset, Yoffset, Hoffset, Xscale, Yscale, Hscale, Rotation: SingleRotmatrix, Color nr, Color OTrap Color offset, Color mult
  fld   qword [esi - 104]   //                  -12          -16       -20      -24     -28      -32    -36       -40..-72                   -76         -80          -84          -88
  fld   qword [esi - 112]
  fld   qword [esi - 120]   //x,y,z
    fld   st(0)            // rotate+scale   x,y,z
    fmul  dword [edi - 36-28]
    fld   st(2)            //y,cz,x,y,z
    fmul  dword [edi - 40-28]
    faddp                  //cz+cy,x,y,z
    fld   st(3)
    fmul  dword [edi - 44-28]
    faddp                  //nz,x,y,z
    fld   st(1)            //x,nz,x,y,z
    fmul  dword [edi - 12-28]
    fld   st(3)            //y,cx,nz,x,y,z
    fmul  dword [edi - 16-28]
    faddp                  //cx+cy,nz,x,y,z
    fld   st(4)
    fmul  dword [edi - 20-28]
    faddp                  //nx,nz,x,y,z
    fxch  st(2)            //x,nz,nx,y,z
    fmul  dword [edi - 24-28]
    fxch  st(3)            //y,nz,nx,cx,z
    fmul  dword [edi - 28-28]
    faddp st(3), st(0)     //nz,nx,cx+cy,z
    fxch  st(3)            //z,nx,cx+cy,nz
    fmul  dword [edi - 32-28]
    faddp st(2), st(0)     //nx,ny,nz
  fld  st(2)               //speedup: map only if distance to surface is less than...
  fadd dword [edi - 24]    //z+off,x,y,z
  fld  dword [edi - 36]    //Hmul,z',x,y,z
  fmul qword [edi - 8]
  fsubp
  fabs
  fld  dword [edi - 36]
  fabs
  fadd qword [esi - 136]   //It3Dex.Rold,  absolute DEstop add!
  fcompp
  fnstsw ax
  shr ah, 1
  jnc @@1
  fcompp                    //nz
  fld   qword [edi - 8]     //0.5
  fmul  dword [edi - 36]    //amplitude H scale
  fsub  dword [edi - 24]    //H offset
  fsubrp                    //-z
  fstp  qword [esi - 32]    //Rout: Double; +56  is distance
  add   esp, 32
  pop   ecx
  ret
@@1:
  fmul  dword [edi - 28]
  fsub  dword [edi - 16]    // offsets after rot+scale!   todo: only check map if Abs(distsphere) < mapscale*2+Abs(offset)
  fstp  qword [esp]
  fmul  dword [edi - 32]
  fsub  dword [edi - 20]
  fstp  qword [esp + 8]
  fstp  qword [esp + 24]
  mov   eax, esp
  mov   edx, [edi - 12]
  mov   ecx, esp
  call  [esi + 268]         //+356 - 88 = 268
//   PMapFunc2:  esi+356    //   eax             edx             ecx
//function GetMapPixelDirectXY(PVec3D: TPVec3D; MapNr: Integer): TVec3D; //Direct pixel coords 0..1 with tiling
  mov   ecx, [edi - 76]
  and   ecx, 3
  fld   qword [esp + ecx * 8]   //col of map
  fmul  dword [edi - 36]    //amplitude H scale
  fsub  dword [edi - 24]    //H offset
  fsub  qword [esp + 24]    //-z
  fstp  qword [esi - 32]    //Rout: Double; +56  is distance
  mov   ecx, [edi - 80]     //Otrap color mapnr
  and   ecx, 3
  fld   qword [esp + ecx * 8]   //col of map
  fadd  dword [edi - 84]
  fmul  dword [edi - 88]
  fstp  qword [esi + 128]   //dfree1 for otrap coloring
  add   esp, 32
  pop   ecx     }
  
 { push  ecx                 // sphere heightmap
  add   esp, -32            // HeightMap[nr: integer; Col nr, Xoffset, Yoff, Zoff, Xscale, Yscale, Hscale, Rotn: SingleM, Col nr, Colo
  fld   qword [esi - 104]   //          -12          -16       -20      -24  -28    -32     -36     -40     -44..-76        -80    -84
  fsub  dword [edi - 28]
  fld   qword [esi - 112]
  fsub  dword [edi - 24]
  fld   qword [esi - 120]   //x,y,z
  fsub  dword [edi - 20]
    fld   st(0)            // rotate+scale   x,y,z
    fmul  dword [edi - 36-32]
    fld   st(2)            //y,cz,x,y,z
    fmul  dword [edi - 40-32]
    faddp                  //cz+cy,x,y,z
    fld   st(3)
    fmul  dword [edi - 44-32]
    faddp                  //nz,x,y,z
    fld   st(1)            //x,nz,x,y,z
    fmul  dword [edi - 12-32]
    fld   st(3)            //y,cx,nz,x,y,z
    fmul  dword [edi - 16-32]
    faddp                  //cx+cy,nz,x,y,z
    fld   st(4)
    fmul  dword [edi - 20-32]
    faddp                  //nx,nz,x,y,z

  fmul  dword [edi - 32]

    fxch  st(2)            //x,nz,nx,y,z
    fmul  dword [edi - 24-32]
    fxch  st(3)            //y,nz,nx,cx,z
    fmul  dword [edi - 28-32]
    faddp st(3), st(0)     //nz,nx,cx+cy,z
    fxch  st(3)            //z,nx,cx+cy,nz
    fmul  dword [edi - 32-32]
    faddp st(2), st(0)     //nx,ny,nz
  fxch
  fmul  dword [edi - 36]
  fxch
    fld  st(2)
    fmul st, st
    fld  st(2)
    fmul st, st
    faddp
    fld  st(1)
    fmul st, st
    faddp
    fsqrt
    fld1
    fsubp   //Rdist,x,y,z
           //speedup: map only if distance to surface is less than...
  fld  st                  //r,r,x,y,z
  fabs
  fld  dword [edi - 40]    //Hmul,r',Rdist,x,y,z
  fabs
  fadd qword [esi - 136]   //abs destop
  fcompp                   //Rdist,x,y,z
  fnstsw ax
  shr ah, 1
  jnc @@1
  fstp  qword [esi - 32]    //Rout: Double; +56  is distance
  fcompp
  fstp  st
  add   esp, 32
  pop   ecx
  ret //
@@1:
  fstp  qword [esp + 24]
  fstp  qword [esp]
  fstp  qword [esp + 8]
  fstp  qword [esp + 16]
  mov   eax, esp
  mov   edx, [edi - 12]
  mov   ecx, esp
  call  [esi + 264]         //+356 - 88 = 268
//   PMapFunc2:  esi+356    //   eax             edx             ecx
//function GetMapPixelDirectXY(PVec3D: TPVec3D; MapNr: Integer): TVec3D; //Direct pixel coords 0..1 with tiling
//    PMapFunc:   TLMSfunction;//+352   pointer to a map function: function GetMapPixelSphere(PVec3D: TPVec3D; MapNr: Integer): TVec3D;
  //  PMapFunc2:  TLMSfunction;//+356   pointer to 2nd map function, PVec3D: X,Y double used to get direct pixel in range 0..1
  mov   ecx, [edi - 16]
  and   ecx, 3
  fld   qword [esp + ecx * 8]   //col of map
  fsub  qword [edi - 8]
  fmul  dword [edi - 40]    //amplitude H scale
  fsubr qword [esp + 24]
  fstp  qword [esi - 32]    //Rout: Double; +56  is distance
  mov   ecx, [edi - 80]     //Otrap color mapnr
  and   ecx, 3
  fld   qword [esp + ecx * 8]   //col of map
  fadd  dword [edi - 84]
  fmul  dword [edi - 88]
  fstp  qword [esi + 128]   //dfree1 for otrap coloring
  add   esp, 32
  pop   ecx    //}

{  fld  st(2)               //speedup: map only if distance to surface is less than...
  fadd dword [edi - 24]    //z+off,x,y,z
  fld  dword [edi - 36]    //Hmul,z',x,y,z
  fmul qword [edi - 8]
  fsubp
  fabs
  fld  dword [edi - 36]
  fabs
  fadd qword [esi - 136]   //It3Dex.Rold,  absolute DEstop add!
  fcompp
  fnstsw ax
  shr ah, 1
  jnc @@1
  fcompp                    //nz
  fld   qword [edi - 8]     //0.5
  fmul  dword [edi - 36]    //amplitude H scale
  fsub  dword [edi - 24]    //H offset
  fsubrp                    //-z
  fstp  qword [esi - 32]    //Rout: Double; +56  is distance
  add   esp, 32
  pop   ecx
  ret
@@1:

  //IFS formula, sine-water (wave)  with Roff
  add  esp, -32
  movupd xmm0, [esi - 120]  //x,y
  movsd  xmm1, [esi - 104]  //z
  mulpd  xmm0, [edi - 32]   //*Scale
  mulsd  xmm1, [edi - 32]
  addpd  xmm0, [edi - 64]   //+translate
  addsd  xmm1, [edi - 48]
  cmp    dword [edi - 76], 0  //apply add+scale
  je @@1
  movsd  xmm5, [esi + 112]  //accumulated scale +200
  mulsd  xmm5, [edi - 32]
  movupd [esi - 120], xmm0
  movsd  [esi - 104], xmm1
  movsd  [esi + 112], xmm5
@@1:
  movupd [esp], xmm0
  movsd  [esp + 16], xmm1
  mov   edx, [edi - 84]     //flipXZ
  and   edx, 1
  fld   qword [edi - 72]    //Amplitude
  shl   edx, 4
  fstp  qword [esp + 24]
  fld   qword [esp + edx]
  cmp   dword [edi - 80], 0  //Circular
  je @@3
  fmul  st(0), st(0)
  fld   qword [esp + 8]
  fmul  st(0), st(0)
  faddp
  fsqrt
  fmul  qword [edi - 16]    //frequency
  cmp   dword [edi - 88], 0 //amplitude on r
  je @@5
  fld1
  fadd  st, st(1)
  fdivr qword [esp + 24]
  fstp  qword [esp + 24]
@@5:
  fcos
  jmp @@4
@@3:
  fmul  qword [edi - 16]    //frequency
  fcos
  fld   qword [esp + 8]
  fmul  qword [edi - 16]    //frequency
  fcos
  faddp
@@4:
  neg   edx
  fmul  qword [esp + 24]    //amplitude (/(R+1)
  fsub  qword [esp + edx + 16]
  cmp   [edi - 76], 0
  jne @@2
  fdiv  qword [edi - 32]
@@2:
  fstp  qword [esi - 32]    //Rout: Double;     //+56
  add  esp, 32       //}

   //IFS formula, Box with trapez   [Z size, Y size, X size, Scale, Add Z, Add Y, Add X, trapez, twist, apply add+scale
 { movupd xmm0, [esi - 120]  //x,y       d  ,   d   ,  d   ,2doubles, 2d,    d   ,  d   ,   d   ,   s  ,   integer
  movsd  xmm1, [esi - 104]  //z
  mulpd  xmm0, [edi - 48]   //*Scale
  mulsd  xmm1, [edi - 48]
  addpd  xmm0, [edi - 80]   //+translate
  addsd  xmm1, [edi - 64]
  cmp    [edi - 96], 0
  je @@1
  movsd  xmm5, [esi + 112]  //accumulated scale
  mulsd  xmm5, [edi - 48]
  movupd [esi - 120], xmm0
  movsd  [esi - 104], xmm1
  movsd  [esi + 112], xmm5
@@1:
  cmp    [edi - 92], 0
  je @@3
  add    esp, -24        //twist
  movupd [esp], xmm0
  movsd  [esp + 16], xmm1
  fld    dword [edi - 92]
  fmul   qword [esp + 16] //z
  fsincos                //cos, sin
  fld    qword [esp + 8]
  fld    qword [esp]     //x,y,c,s
  fld    st(3)
  fmul   st, st(1)       //s*x,x,y,c,s
  fld    st(2)
  fmul   st, st(4)
  faddp
  fstp   qword [esp]     //x,y,c,s
  fmulp  st(2), st       //y,c*x,s
  fmulp  st(2), st       //c*x, s*y
  fsubrp
  fstp   qword [esp + 8]
  movupd xmm0, [esp]
  add    esp, 24
@@3:
 // pshufd xmm3, xmm0, $4E    //y to xmm3
  movsd  xmm3, xmm1
  andpd  xmm0, [edi]        // abs=and [$7FFFFFFF,$7FFFFFFF]
  andpd  xmm1, [edi]
  mulsd  xmm3, [edi - 88]   //trapez
  subpd  xmm0, [edi - 32]   //x,y size
  subsd  xmm1, [edi - 16]   //z size
  subsd  xmm0, xmm3         //trapez    todo: downscale DE if in trapez region...
  maxsd  xmm1, xmm0
  UNPCKHPD xmm0, xmm0
  maxsd  xmm1, xmm0
  cmp    [edi - 96], 0
  jne @@2
  divsd  xmm1, [edi - 48]
@@2:
  mov eax, [edi - 100]
  movsd  [esi - 32], xmm1   //Rout: Double;     //+56
  and eax, 3
  fld  qword [esi + eax * 8 - 128]
  fmul dword [edi - 108]
  fadd dword [edi - 104]
  fstp qword [esi + 128]  }

  //IFS formula, sphere with scale + radius + xyz scale, SSE2   + new otrap option
{.Version = 6
.DEoption = 20
.SSE2
.Double Radius = 1
.2Doubles Scale = 2
.2Doubles Z add = 0
.Double Y add = 0
.2Doubles X add = 3
.DSqrReci Z size = 1
.DSqrReci Y size = 1
.DSqrReci X size = 1
.Integer apply scale+add = 1     -100
.Integer OTrap option (0..3) = 0   -104
.Single OTrap offset = 1         -108
.Single OTrap scale = 1          -112
.Double Inside radius = 0  }   //-120  new: DE = Max(DE, DEinside = Inside_radius - R)

 { movupd xmm0, [esi - 120]  //x,y
  movsd  xmm1, [esi - 104]  //z
  mulpd  xmm0, [edi - 32]   //*Scale
  mulsd  xmm1, [edi - 32]
  addpd  xmm0, [edi - 64]   //+translate
  addsd  xmm1, [edi - 48]
  cmp    [edi - 100], 0
  je @@1
  movsd  xmm5, [esi + 112]  //accumulated scale +200
  mulsd  xmm5, [edi - 32]
  movupd [esi - 120], xmm0
  movsd  [esi - 104], xmm1
  movsd  [esi + 112], xmm5
@@1:
  movapd xmm3, [edi - 96]
  movsd  xmm4, [edi - 80]
  mulpd  xmm0, xmm3         //y,x size
  mulsd  xmm1, xmm4
  mulpd  xmm0, xmm0
  mulsd  xmm1, xmm1
  addsd  xmm1, xmm0         // zz'+xx'
  unpckhpd xmm0, xmm0
  addsd  xmm1, xmm0
  sqrtsd xmm1, xmm1         // |vec*scale|
  movsd  xmm2, [edi - 120]  //inside radius
  subsd  xmm2, xmm1         //DE' insideR
  subsd  xmm1, [edi - 16]   //DE' outsideR
  maxsd  xmm1, xmm2
  andpd  xmm3, [edi]        //   / min(scales)    (here max of reciscales)
  andpd  xmm4, [edi]        //abs
  maxsd  xmm4, xmm3
  unpckhpd xmm3, xmm3
  maxsd  xmm4, xmm3
  divsd  xmm1, xmm4

{  andpd  xmm3, [edi]
  andpd  xmm4, [edi]
  movapd xmm5, xmm3
  movsd  xmm6, xmm4
  addsd  xmm6, xmm5
  shufpd xmm5, xmm5, 1
  addsd  xmm6, xmm5
  addsd  xmm6, [edi + 24]
//  mulpd  xmm3, xmm3
//  mulsd  xmm4, xmm4
  mulpd  xmm3, [edi - 96]   //old calc, DE is stretched like size
  mulsd  xmm4, [edi - 80]   //y,x size  DSqrReci !  -> D+reciD, multiply before sqr
//  mulpd  xmm3, xmm3
//  mulsd  xmm4, xmm4
  andpd  xmm3, [edi]
  andpd  xmm4, [edi]        //abs
  addsd  xmm4, xmm3
  shufpd xmm3, xmm3, 1
  addsd  xmm4, xmm3
  sqrtsd xmm4, xmm4
  divsd  xmm4, xmm1
  divsd  xmm2, xmm4  //}

 { movapd xmm3, [edi - 96]   //y,x size
  movsd  xmm4, [edi - 80]   //z size
  movsd  xmm2, [edi - 16]   //radius
  movsd  xmm7, [edi - 120]  //inside radius
  movapd xmm5, xmm3
  movsd  xmm6, xmm4
  shufpd xmm2, xmm2, 1
  shufpd xmm7, xmm7, 1
  mulpd  xmm3, xmm2
  mulsd  xmm4, xmm2
  mulpd  xmm5, xmm7
  mulsd  xmm6, xmm7

  andpd  xmm0, [edi]      //and $7FFFF.. abs()
  andpd  xmm1, [edi]
  movapd xmm2, xmm0
  movsd  xmm7, xmm1
  subpd  xmm0, xmm3
  subsd  xmm1, xmm4
  subpd  xmm2, xmm5
  subsd  xmm7, xmm6

  mulpd  xmm0, xmm0
  mulsd  xmm1, xmm1
  mulpd  xmm2, xmm2
  mulsd  xmm7, xmm7
  addsd  xmm1, xmm0
  addsd  xmm7, xmm2
  shufpd xmm0, xmm0, 1      //unpckhpd ?
  shufpd xmm2, xmm2, 1
  addsd  xmm1, xmm0
  addsd  xmm7, xmm2
  sqrtsd xmm1, xmm1         //outside DE   make sqrtpd...
  sqrtsd xmm7, xmm7         //inside DE
  xorpd  xmm0, xmm0
  subsd  xmm0, xmm7

  maxsd  xmm1, xmm0  }

{  cmp    [edi - 100], 0
  jne @@2
  divsd  xmm1, [edi - 32]
@@2:
  mov eax, [edi - 104]
  movsd  [esi - 32], xmm1   //Rout: Double;     //+56
  and eax, 3
  fld  qword [esi + eax * 8 - 128]
  fmul dword [edi - 112]
  fadd dword [edi - 108]
  fstp qword [esi + 128] // }



 {   testhybridOptionsStrings: array[0..14] of String = ('Scale','Min R/IR','Fold','RotationX','RotationY','RotationZ',
                                                           -$10    -$18-$20   -$28        -$2C..-4C
      'Inv xC','Inv yC','Inv zC','Inv Radius','FoldX, XY angle','FoldX, XZ angle','FoldY, XY angle','FoldY, YZ angle',
        -$54     -$5C     -$64      -$6C        -$74  -$7C         -$84 -$8C        -$94 -$9C           -$A4  -$AC
      'Abs XYZ switches');     }
         //-$B0
{  push esi
  push ebx
  mov  esi, [ebp+$08]
  mov  ebx,eax
  mov  esi, [esi+$30]
  add  esp, -$20
  add  esi, -$40
  fld  qword ptr [esi-$28+$40]       //fold
  fld  qword ptr [ebx]               //x,f   #2
  fmul qword ptr [esi-$0000008c+$40] //x',f
  fld  qword ptr [ecx]               //z,x',f  #3
  fmul qword ptr [esi-$00000084+$40] //z',x',f
  fsubp                              //zx,f
  fld  qword ptr [ebx]               //x,zx,f  #3
  fmul qword ptr [esi-$00000084+$40]
  fld  qword ptr [ecx]               //z,x',zx,f  #4
  fmul qword ptr [esi-$0000008c+$40]
  faddp                              //zx2,zx,f  #3
  fstp qword ptr [esp+$08]           //zx,f  #2    esp8=zx2
  fld  st                            //#3
  fmul qword ptr [esi-$7c+$40]       //zx',zx,f
  fld  qword ptr [edx]               //#4
  fmul qword ptr [esi-$74+$40]       //y',zx',zx,f
  fsubp                              //yzx,zx,f  #3
  fxch                               //zx,yzx,f
  fmul qword ptr [esi-$74+$40]
  fld  qword ptr [edx]               //#4
  fmul qword ptr [esi-$7c+$40]       //y',zx',yzx,f
  faddp                              //yzx2,yzx,f  #3
  fxch
  fld  st                            //yzx,yzx,yzx2,f  #4
  fsub st, st(3)                     //yzx-f,yzx,yzx2,f
  fabs
  fadd st, st(1)                     //abs(yzx-f)+yzx,yzx,yzx2,f
  fxch                               //yzx,abs(yzx-f)+yzx,yzx2,f
  fadd st, st(3)
  fabs                               //abs(yzx+f),abs(yzx-f)+yzx,yzx2,f
  fsubrp                             //abs(yzx+f)-abs(yzx-f)+yzx,yzx2,f
  fld  st                            //ayzxf,ayzxf,yzx2,f    #4
  fmul qword ptr [esi-$7c+$40]       //ayzxf',ayzxf,yzx2,f
  fld  st(2)                         //yzx2,ayzxf',ayzxf,yzx2,f   #5
  fmul qword ptr [esi-$74+$40]
  fsubp                              //ayzxf2,ayzxf,yzx2,f   #4
  fld  st                            //ayzxf2,ayzxf2,ayzxf,yzx2,f  #5
  fmul qword ptr [esi-$0000008c+$40] //ayzxf2',ayzxf2,ayzxf,yzx2,f  #5
  fld  qword ptr [esp+$08]           //zx2,ayzxf2',ayzxf2,ayzxf,yzx2,f  #6
  fmul qword ptr [esi-$00000084+$40] //zx2',ayzxf2',ayzxf2,ayzxf,yzx2,f
  fsubp                              //kk,ayzxf2,ayzxf,yzx2,f  #5
  fxch st(2)                         //ayzxf,ayzxf2,kk,yzx2,f
  fmul qword ptr [esi-$74+$40]       //ayzxf',ayzxf2,kk,yzx2,f
  fxch                               //ayzxf2,ayzxf',kk,yzx2,f
  fxch st(3)                         //yzx2,ayzxf',kk,ayzxf2,f  #5
  fmul qword ptr [esi-$7c+$40]       //yzx2',ayzxf',kk,ayzxf2,f
  faddp                              //ya3,kk,ayzxf2,f #4
  fxch st(2)                         //ayzxf2,kk,ya3,f
  fmul qword ptr [esi-$00000084+$40] //ayzxf2',kk,ya3,f
  fld  qword ptr [esp+$08]           //zx2,ayzxf2',kk,ya3,f  #5
  fmul qword ptr [esi-$0000008c+$40] //zx2',ayzxf2',kk,ya3,f
  faddp                              //za3,kk,ya3,f  #4
  fld  st(2)                         //ya3,za3,kk,ya3,f  #5
  fmul qword ptr [esi-$000000ac+$40] //ya3',za3,kk,ya3,f
  fld  st(1)                         //za3,ya3',za3,kk,ya3,f  #6
  fmul qword ptr [esi-$000000a4+$40] //za3',ya3',za3,kk,ya3,f
  fsubp                              //yz4,za3,kk,ya3,f   #5
  fxch                               //za3,yz4,kk,ya3,f
  fmul qword ptr [esi-$000000ac+$40] //za3',yz4,kk,ya3,f
  fxch st(3)                         //ya3,yz4,kk,za3',f   #5
  fmul qword ptr [esi-$000000a4+$40] //ya3',yz4,kk,za3',f
  faddp st(3), st                    //yz4,kk,jj,f   #4
//  fxch  st(2)                        //jj,kk,yz4,f
//  fstp qword ptr [esp+$08]           //kk,yz4,f   #3   esp8=jj
 // fxch                               //yz4,kk,f
  fld  st                            //yz4,yz4,kk,jj,f   #4
  fmul qword ptr [esi-$9c+$40]       //yz4',yz4,kk,jj,f
  fld  st(2)                         //kk,yz4',yz4,kk,jj,f   #5
  fmul qword ptr [esi-$94+$40]       //kk',yz4',yz4,kk,jj,f
  fsubp                              //ll,yz4,kk,jj,f   #4
  fxch  st(2)                        //kk,yz4,ll,jj,f
  fmul qword ptr [esi-$9c+$40]       //kk',yz4,ll,jj,f
  fxch                               //yz4,kk',ll,jj,f
  fmul qword ptr [esi-$94+$40]       //yz4',kk',ll,jj,f
  faddp                              //mm,ll,jj,f     #3
  fxch                               //ll,mm,jj,f
  fld  st                            //ll,ll,mm,jj,f   #4
  fsub st, st(4)                     //ll',ll,mm,jj,f
  fabs
  fadd st, st(1)                     //ll'',ll,mm,jj,f
  fxch                               //ll,ll'',mm,jj,f
  fadd st, st(4)
  fabs
  fsubrp                             //nn,mm,jj,f
  fld  st                            //nn,nn,mm,jj,f
  fmul qword ptr [esi-$0000009c+$40] //nn',nn,mm,jj,f
  fld  st(2)                         //mm,nn',nn,mm,jj,f   #5
  fmul qword ptr [esi-$00000094+$40] //mm',nn',nn,mm,jj,f
  fsubp                              //oo,nn,mm,jj,f    #4
  fld  st                            //oo,oo,nn,mm,jj,f   #5
  fmul qword ptr [esi-$000000ac+$40] //oo',oo,nn,mm,jj,f
  fld  st(4)//qword ptr [esp+$08]    //jj,oo',oo,nn,mm,jj,f   #6 #7
  fmul qword ptr [esi-$000000a4+$40] //jj',oo',oo,nn,mm,jj,f
  fsubp                              //jo,oo,nn,mm,jj,f   #5
  fld  qword ptr [esi-$00000094+$40] //cf,jo,oo,nn,mm,jj,f
  fmulp st(3), st                    //jo,oo,nn',mm,jj,f   #5      *nn
 // fxch st(2)                         //nn',oo,jo,mm,jj,f
  fxch st(3)                         //mm,oo,nn',jo,jj,f
  fmul qword ptr [esi-$0000009c+$40] //mm',oo,nn',jo,jj,f
  faddp st(2), st                    //oo,mn2,jo,jj,f   #4
  fmul qword ptr [esi-$000000a4+$40] //oo',mn2,jo,jj,f
  fld  qword ptr [esi-$000000ac+$40] //cf2,oo',mn2,jo,jj,f
  fmulp st(4), st                    //oo',mn2,jo,jj',f
  faddp st(3), st                    //mn2,jo,jo2,f
//  fxch                               //mn2,jo,jo2,f
  fxch st(2)                         //jo2,jo,mn2,f
  fld  st                            //jo2,jo2,jo,mn2,f    #5
  fsub st, st(4)                     //
  fabs                               //
  fadd st, st(1)                     //
  fxch
  fadd st, st(4)
  fabs
  fsubrp                             //jj,jo,mn2,f   #4
  mov  eax, [esi-$b0+$40]
  nop
  test eax, $04
  jz   @4e9
  fabs
@4E9:  test eax, $02
  jz   @4fa
  fxch st(1)
  fabs
  fxch st(1)
@4FA:  test eax, $01
  jz   @50b
  fxch st(2)
  fabs
  fxch st(2)
@50B:  fadd qword ptr [esi-$64+$40]
  fld  qword ptr [esi-$5c+$40]       //#5
  faddp st(2), st                    //#4
  fld  qword ptr [esi-$54+$40]       //#5
  faddp st(3), st                    //#4
  fld  st                            //#5
  fmul st, st
  fld  st(2)                         //#6
  fmul st, st
  faddp                              //#5
  fld  st(3)                         //#6
  fmul st, st
  faddp                              //#5
  fmul qword ptr [esi-$6c+$40]
  fcom qword ptr [esi-$20+$40]
  fstsw ax
  shr  ah, 1
  jnb  @547
  fstp st                            //#4
  fld  qword ptr [esi-$18+$40]       //#5
  jmp  @55d
@547:  fld1                          //#6
  fcom st(1)
  fstsw ax
  shr  ah, 1
  jb   @558
  fstp st                            //#5
  fdivr qword ptr [esi-$10+$40]
  jmp  @55d
@558:  fcompp                        //#4
  fld  qword ptr [esi-$10+$40]       //#5
@55D:  fld qword ptr [ecx+$08]       //#6
  fmul st, st(1)
  fstp qword ptr [ecx+$08]           //#5
  fmul st(3), st
  fmul st(2), st
  fmulp                              //#4
  fld  qword ptr [esi-$10+$40]       //#5
  fld  qword ptr [esi-$64+$40]       //#6
  fmul st, st(1)
  fsubp st(2), st                    //#5
  fld  qword ptr [esi-$5c+$40]       //#6
  fmul st, st(1)
  fsubp st(3), st                    //#5
  fmul qword ptr [esi-$54+$40]       //#5
  fsubp st(3), st                    //#4
  fxch st(2)
  fld  st                            //#5
  fmul dword ptr [esi-$44+$40]
  fld  st(2)                         //#6
  fmul dword ptr [esi-$48+$40]
  faddp                              //#5
  fld  st(3)                         //#6
  fmul dword ptr [esi-$4c+$40]
  faddp                              //#5
  fld  st(1)                         //#6
  fmul dword ptr [esi-$2c+$40]
  fld st(3)                          //#7
  fmul dword ptr [esi-$30+$40]
  faddp                              //#6
  fld  st(4)                         //#7
  fmul dword ptr [esi-$34+$40]
  faddp                              //#6
  fxch st(2)
  fmul dword ptr [esi-$38+$40]
  fxch st(3)
  fmul dword ptr [esi-$3c+$40]
  faddp st(3), st                    //#5
  fxch st(3)
  fmul dword ptr [esi-$40+$40]
  mov  esi, [ebp+$08]
  faddp st(2), st                    //#4
  fadd qword ptr [esi+$18]
  fstp qword ptr [ebx]      // ?    //#1
  fadd qword ptr [esi+$20]
  fstp qword ptr [edx]      //x,?   //#2
  fadd qword ptr [esi+$28]
  fstp qword ptr [ecx]      //y,x,? //#3
  fstp st
  add esp, $20
  mov eax,ebx
  pop ebx
  pop esi

  {  push esi       //amazing surf
    push edi
    push ebx
    mov  edi, [ebp+$08]
    mov  ebx, eax
    mov  esi, [edi+$30]
    add  edi, $00000080
    cmp  dword [edi+$50], 0
    jnle @4b
    inc  dword [edi+$50]
    fld  qword [esi-$10]
    fstp qword [edi+$48]
@4b: fld qword [edi+$48]
    fld1
    fld  st(1)
    fabs
    fsubrp
    fmul qword [esi-$54]
    faddp
    fstp qword [edi+$48]  //scale
    fld  qword [esi-$28]  //fold
    fld  qword [ebx]      //x,fold
    fld  st               //x,x,fold
    fsub st, st(2)        //x-fold,x,fold
    fabs
    fadd st, st(1)        //x+abs(x-fold),x,fold
    fxch
    fadd st, st(2)
    fabs
    fsubrp                //x',fold
    fld  qword ptr [edx]
    fld  st(0)
    fsub st, st(3)
    fabs
    fadd st, st(1)
    fxch
    fadd st, st(3)
    fabs
    fsubrp                //y',x',fold
    fst  qword ptr [edx]
    fmul st, st           //yy,x',fold
    fxch st(1)
    fst  qword ptr [ebx]   //x',yy,fold
    fmul st, st
    faddp                 //xx+yy,fold
    fstp st(1)            //xx+yy
    cmp  dword ptr [esi-$58], 0   //sphere / cylinder
    jnz  @9f
    fld  qword ptr [ecx]
    fmul st, st
    faddp                 //xx+yy+zz
@9F: fcom qword ptr [esi-$20]
    fstsw ax
    shr  ah, 1
    jnb  @af
    fstp st
    fld  qword ptr [esi-$18]
    jmp  @3c5
@AF: fld1
    fcom st(1)
    fstsw ax
    shr  ah, 1
    jb   @3c0
    fstp st(0)
    fdivr qword ptr [edi+$48]
    jmp  @3c5
@3C0: fcompp
    fld  qword ptr [edi+$48]
@3C5: fld qword ptr [ecx+$08]  //w,scale'
    fmul st, st(1)
    fstp qword ptr [ecx+$08]
    fld  qword ptr [ecx]       //z,scale'
    fmul st, st(1)
    fadd qword ptr [edi-$58]   //z',scale'
    fld  qword ptr [edx]       //y,z',scale'
    fmul st, st(2)
    fadd qword ptr [edi-$60]   //y',z',scale'
    fld  qword ptr [ebx]
    fmul st, st(3)
    fadd qword ptr [edi-$68]   //x',y',z',scale'
    fld  st
    fmul dword ptr [esi-$44]
    fld  st(2)
    fmul dword ptr [esi-$48]
    faddp
    fld  st(3)
    fmul dword ptr [esi-$4c]
    faddp
    fld  st(1)
    fmul dword ptr [esi-$2c]
    fld  st(3)
    fmul dword ptr [esi-$30]
    faddp
    fld  st(4)
    fmul dword ptr [esi-$34]
    faddp
    fxch st(2)
    fmul dword ptr [esi-$38]
    fxch st(3)
    fmul dword ptr [esi-$3c]
    faddp st(3), st
    fxch st(3)
    fmul dword ptr [esi-$40]
    faddp st(2), st
    fstp qword ptr [ebx]
    fstp qword ptr [edx]
    fstp qword ptr [ecx]
    fstp st
    mov eax, ebx
    pop ebx
    pop edi
    pop esi
//  pop ebp
//  ret $0008

{asm
    push  esi                   //smoothbox lucas     with options  fold  fold x2
    push  edi
    push  ebx
    mov   esi, [ebp + 8]        //PIteration3D
    mov   edi, [esi + 48]       //was:PAligned16
    mov   ebx, eax
    add   esi, $70
    jmp   @3
    nop
    nop
    nop
@intpow:               // eax = exponent
    shr   eax, 1
    jz    @a
    jnc   @0
    fld   st
    jmp   @1
@0: fld1
    fxch               // base, 1(result)
@1: fmul  st, st       // base * base
@2: shr   eax, 1
    jnc   @1
    fmul  st(1), st    //base', result*base'
    jnz   @1
    fstp  st
@a: ret
 //   nop
@sboxfold:             //address of float in eax
    fld   qword [eax]       //x (y or z)
    fabs
    push  eax
    mov   eax, [edi-$34]
    fld   st
    call  @intpow          //x^,x
    pop   eax
    fmul  qword [edi - $3C] //xp,x
    fxch                    //x,xp
    fld   qword [edi - $28] //fold,x,xp
    fadd  st, st            //2*fold,x,xp
    fsub  st, st(1)         //2*fold-x,x,xp
    fmul  st, st(2)         //(2*fold-x)*xp,x,xp
    faddp                   //(2*fold-x)*xp+x,xp
    fld1                    //1,(2*fold-x)*xp+x,xp
    faddp st(2), st         //(2*fold-x)*xp+x,xp+1
    fdivrp                  //(2*fold-x)*xp+x/(1+xp)
    test  byte [eax + 7], $80  //sign bit
    jns   @4
    fchs
@4: ret
    nop
@3: call  @sboxfold
    mov   eax, edx
    call  @sboxfold
    mov   eax, ecx
    call  @sboxfold            //z,y,x
    cmp   dword [esi + $60], 0
    jnle  @5
    inc   dword [esi + $60]
    fld   qword [edi - $10]
    fstp  qword [esi + $58]
@5: fld   qword [esi + $58]
    fld1
    fld   st(1)
    fabs
    fsubrp
    fmul  qword [edi - $30]
    faddp
    fstp  qword [esi + $58]
    fld   qword [edi - $20]
    fcomp qword [edi]   //0.99  cs099 //
    fstsw ax
    shr   ah, 1
    jb    @6
    fld1
    jmp   @7
 //   nop
@6: fld   st(2)
    fmul  st, st
    fld   st(2)
    fmul  st, st
    faddp
    fld   st(1)
    fmul  st, st
    faddp           //rr,z,y,x
    fld1
    fadd  qword [edi - $20]
    fmul  qword [edi - 8]   //0.5*(1+MinR),rr,z,y,x
    fld1
    fsub  qword [edi - $20]
    fmul  qword [edi - 8]  //0.5*(1-MinR),0.5*(1+MinR),rr,z,y,x
    fxch  st(2)            //rr,m,n,z,y,x
    fsub  st, st(1)        //rr-m,m,n,z,y,x
    ftst
    fstsw ax
    push  eax              //sign bit
    fabs
    fdiv  st, st(2)        //r1,m,n,z,y,x
    fld   st               //r1,r1,m,n,z,y,x
    mov   eax, [edi - $40]
    shr   eax, 1
    jnc   @9
    fsqrt
    rcl   eax, 1
@9: call  @intpow
    fmul  qword [edi - $48] //r1^*fixballfold=rp,r1,m,n,z,y,x
    fld1
    fadd  st, st(1)        //rp+1,rp,r1,m,n,z,y,x
    fxch  st(2)
    faddp                  //rp+r1,rp+1,m,n,z,y,x
    fdivrp                 //(rp+r1)/(rp+1),m,n,z,y,x
    pop   eax
    fmulp st(2), st        //m,(rp+r1)/(rp+1)*n,z,y,x
    fxch
    shr   ah, 1
    jnb   @8
    fchs
@8: faddp                  //m+rs*(rp+r1)/(rp+1)*n,z,y,x
@7: fld   qword [esi + $58]//scale,r',z,y,x
    fdivrp                 //scale/r',z,y,x
    fld   qword [ecx + 8]
    fmul  st, st(1)
    fstp  qword [ecx + 8]
    fmul  st(3), st
    fmul  st(2), st
    fmulp
    fadd  qword [esi - $48]
    fstp  qword [ecx]
    fadd  qword [esi - $50]
    fstp  qword [edx]
    fadd  qword [esi - $58]
    fstp  qword [ebx]
    mov   eax, ebx
    pop   ebx
    pop   edi
    pop   esi


{asm
    push  esi                   //Amazing box  x87     with options  fold  fold x2
    push  edi
    mov   esi, [ebp + 8]        //PIteration3D
    mov   edi, [esi + 48]       //was:PAligned16
    fld   qword [ecx]           //x
    fld   qword [edx]
    fld   qword [eax]           //x,y,z
    fld   st
    fmul  qword [edi - 24]
    fld   st(2)
    fmul  qword [edi - 32]
    faddp
    fld   st(3)
    fmul  qword [edi - 40]
    faddp                       //foldx,x,y,z     folding with x = abs(x+fold) - abs(x-fold) - x
    fadd  qword [edi - 16]
    fld   st(1)
    fsub  st, st(1)
    fabs
    fxch                        //foldx,abs(x-fold),x,y,z
    fadd  st, st(2)
    fabs
    fsubrp
    fsub  st, st(1)             //newx,x,y,z
    fld   st(1)
    fmul  qword [edi - 56]
    fld   st(3)
    fmul  qword [edi - 64]
    faddp
    fld   st(4)
    fmul  qword [edi - 72]
    faddp                       //foldy,newx,x,y,z
    fadd  qword [edi - 48]
    fld   st(3)
    fsub  st, st(1)
    fabs
    fxch                        //foldy,abs(y-yfold),newx,x,y,z
    fadd  st, st(4)
    fabs
    fsubrp
    fsub  st, st(3)             //newy,newx,x,y,z
    fxch  st(2)
    fmul  qword [edi - 88]      //x*az,newx,newy,y,z
    fxch  st(3)                 //y,newx,newy,z',z
    fmul  qword [edi - 96]
    faddp st(3), st             //newx,newy,z'',z
    fld   st(3)
    fmul  qword [edi - 104]
    fadd  qword [edi - 80]
    faddp st(3), st             //newx,newy,foldz,z
    fld   st(2)
    fsub  st, st(4)
    fabs                        //abs(z-foldz),newx,newy,foldz,z
    fxch  st(3)                 //foldz,newx,newy,abs(z-foldz),z
    fadd  st, st(4)
    fabs
    fsubrp st(3), st            //newx,newy,abs(z+foldz)-abs(z-foldz),z
    fxch  st(3)
    fsubp st(2), st             //newy,newz,newx
    fstp  qword [edx]
    fstp  qword [ecx]
    fstp  qword [eax]
    pop   edi
    pop   esi  }

//    var xa, ya, za, R, cosPhi, sinPhi, cosTheta, sinTheta, ph, th: Double;
//    var mul, rr: Double;
 //   dSin1, dCos1, dSin2, dCos2, pp: Double;
//    q: TQuaternion;
 //   v1: TVec3D;
//    z1, z2: TComplex;
 //   h, xx,yy,zz,aa,delta: Double;
 //   i, a: Integer;
 //   xyzIn, xyzOut: array[0..2] of Double;
 //   i, i2, i3: Integer;
  //  cxy, czw, cccs, ccsn: TComplex;
//x4,y4,z4,x2,y2,z2,uu,vv: Double;
//const c1d3 : Double = 1/3;  null: Single = 1E-10;
//const complex1dsqrt: TComplex = (-0.5, 0);
//const root2: Single = 1.4142136;
{begin
    with TPIteration3Dext(Integer(PIteration3D) - 56)^ do
    begin
{void circInvert(inout vec3 p, inout float dz, in float r) {
	float l = length(p);
	if (l<r) {
    p*=r*r/(l*l);
    dz*=r*r/(l*l);}
 {vec3 formula(in vec3 a, in vec3 p, inout float dz) {
	if (abs(p.x)<linear_a.x&&abs(p.y)<linear_a.y&&abs(p.z)<linear_a.z)
		nonlinearPull(a,dz,linear_a.x,linear_a.y,linear_a.z);
	wrapBox(a,wrap.x,wrap.y,wrap.z);
	circInvert(a,dz,radius);
	a*=scale; dz*=abs(scale.x);
	rotate(a,dz,angle/180*3.14159265358979323846264); // Ditto?
	a+=p; dz+=1;
	linearPull(a,dz,linear_b.x,linear_b.y,linear_b.z); // ?
  return a;
void linearPull(inout vec3 p, inout float dz, float h, float w, float d) {
	if (abs(p.x)>w&&abs(p.y)>h&&abs(p.z)>d) {
		h*=2; w*=2; d*=2;
		if (p.x<0) p.x+=w;
		else p.x-=w;
		if (p.y<0) p.y+=h;
		else p.y-=h;
    if (p.z<0) p.z+=d;
    else p.z-=d;
void nonlinearPull(inout vec3 p, inout float dz, float h, float w, float d) {
	if (abs(p.x)>w&&abs(p.y)>h&&abs(p.z)>d) {
		h*=2; w*=2; d*=2;
		if (p.x>0) p.x-=w*floor(p.x/w);
		else p.x-=w*ceil(p.x/w);
		if (p.y>0) p.y-=h*floor(p.y/h);
		else p.y-=h*ceil(p.y/h);
   	if (p.z>0) p.z-=d*floor(p.z/d);
   	else p.z-=d*ceil(p.z/d);
          -12     -16       -24      -28       -32        -36        -40    -44
       ('Scale','BoxFold','CFold','NonLin X','NonLin Y','NonLin Z','Lin X','Lin Y',
        'Lin Z','Rotate X','Rotate Y','Rotate Z', nonlinvary,linvary }
      // -48        -52..-84                        -88        -92
 {     if bFirstIt = 0 then
      begin
        PSingle(@Dfree1)^ := PSingle(Integer(PVar) - 28)^;
        PSingle(Integer(@Dfree1) + 4)^ := PSingle(Integer(PVar) - 32)^;
        PSingle(@Dfree2)^ := PSingle(Integer(PVar) - 36)^;
        PSingle(Integer(@Dfree2) + 4)^ := PSingle(Integer(PVar) - 40)^;
        PSingle(@Deriv3)^ := PSingle(Integer(PVar) - 44)^;
        PSingle(Integer(@Deriv3) + 4)^ := PSingle(Integer(PVar) - 48)^;
        Inc(bFirstIt);
      end;

  //    if (abs(J1) < PSingle(@Dfree1)^) and (abs(J2) < PSingle(Integer(@Dfree1) + 4)^) and    //Mandelex
    //     (abs(J3) < PSingle(@Dfree2)^) and (abs(x) > PSingle(@Dfree1)^) and
      if (abs(J1) < x) and (abs(J2) < y) and    //Mandelex
         (abs(J3) < z) and (abs(x) > PSingle(@Dfree1)^) and
         (abs(y) > PSingle(Integer(@Dfree1) + 4)^) and (abs(z) > PSingle(@Dfree2)^) then
      begin //nonlin pull
        PSingle(@Dfree1)^ := PSingle(@Dfree1)^ * PSingle(Integer(PVar) - 88)^;
        PSingle(Integer(@Dfree1) + 4)^ := PSingle(Integer(@Dfree1) + 4)^ * PSingle(Integer(PVar) - 88)^;
        PSingle(@Dfree2)^ := PSingle(@Dfree2)^ * PSingle(Integer(PVar) - 88)^;
        if x > 0 then x := MaxCD(0, x - PSingle(@Dfree1)^ * Trunc(x / PSingle(@Dfree1)^))
                 else x := MinCD(0, x - PSingle(@Dfree1)^ * (1 + Trunc(x / PSingle(@Dfree1)^)));
        if y > 0 then y := MaxCD(0, y - PSingle(Integer(@Dfree1) + 4)^ * Trunc(y / PSingle(Integer(@Dfree1) + 4)^))
                 else y := MinCD(0, y - PSingle(Integer(@Dfree1) + 4)^ * (1 + Trunc(y / PSingle(Integer(@Dfree1) + 4)^)));
        if z > 0 then z := MaxCD(0, z - PSingle(@Dfree2)^ * Trunc(z / PSingle(@Dfree2)^))
                 else z := MinCD(0, z - PSingle(@Dfree2)^ * (1 + Trunc(z / PSingle(@Dfree2)^)));
      end;
      x := abs(x+PSingle(Integer(PVar) - 16)^) - abs(x-PSingle(Integer(PVar) - 16)^) - x;
      y := abs(y+PSingle(Integer(PVar) - 16)^) - abs(y-PSingle(Integer(PVar) - 16)^) - y;
      z := abs(z+PSingle(Integer(PVar) - 16)^) - abs(z-PSingle(Integer(PVar) - 16)^) - z;
      rr := x*x + y*y + z*z;
      if (rr < PDouble(Integer(PVar) - 24)^) then
        rr := (PDouble(Integer(PVar) - 24)^ + s03) / (rr + s03) * PSingle(Integer(PVar) - 12)^ //circ invert + scale
      else rr := PSingle(Integer(PVar) - 12)^;
      x := x * rr;
      y := y * rr;
      z := z * rr;
      w := w * rr;
     //rotate

      if (abs(x) > PSingle(Integer(@Dfree2) + 4)^) and (abs(y) > PSingle(@Deriv3)^) and
         (abs(z) > PSingle(Integer(@Deriv3) + 4)^) then   //lin pull
      begin            //only one value + adjust w to w := w * NewLength(vec) / OldLength(vec);
        PSingle(Integer(@Dfree2) + 4)^ := PSingle(Integer(@Dfree2) + 4)^ * PSingle(Integer(PVar) - 92)^;
        PSingle(@Deriv3)^ := PSingle(@Deriv3)^ * PSingle(Integer(PVar) - 92)^;
        PSingle(Integer(@Deriv3) + 4)^ := PSingle(Integer(@Deriv3) + 4)^ * PSingle(Integer(PVar) - 92)^;
        if x < 0 then x := MinCD(0, x + PSingle(Integer(@Dfree2) + 4)^)
                 else x := MaxCD(0, x - PSingle(Integer(@Dfree2) + 4)^);
        if y < 0 then y := MinCD(0, y + PSingle(@Deriv3)^)
                 else y := MaxCD(0, y - PSingle(@Deriv3)^);
        if z < 0 then z := MinCD(0, z + PSingle(Integer(@Deriv3) + 4)^)
                 else z := MaxCD(0, z - PSingle(Integer(@Deriv3) + 4)^);
      end;

    end;
{      th := ArcTan2(y, x);
      ph := ArcTan2(z, Sqrt(Sqr(x) + Sqr(y)));
      R := Power(Rout, 0.5 * PDouble(Integer(PVar) - 32)^);
      SinCosD(PDouble(Integer(PVar) - 32)^ * ph, sinPhi, cosPhi);
      SinCosD(PDouble(Integer(PVar) - 32)^ * th, sinTheta, cosTheta);
      x := R * cosPhi * cosTheta + J1;
      y := R * cosPhi * sinTheta + J2;
      z := PDouble(Integer(PVar) - 24)^ * R * sinPhi + J3;
      th := ArcTan2(y, x);
      ph := ArcTan2(z, Sqrt(Sqr(x) + Sqr(y)));
      R := Power(Rout, 0.5 * PDouble(Integer(PVar) - 16)^);
      SinCosD(PDouble(Integer(PVar) - 16)^ * ph, sinPhi, cosPhi);
      SinCosD(PDouble(Integer(PVar) - 16)^ * th, sinTheta, cosTheta);
      x := x + R * cosPhi * cosTheta + J1;
      y := y + R * cosPhi * sinTheta + J2;
      z := z + PDouble(Integer(PVar) - 24)^ * R * sinPhi + J3;

    end;
       //David M
    {  R := Sqrt(Rout);
      ya := (1 - Abs(x)) / R * Power(y + z, 5) + 2 * x * z;
      xa := x * x - y * y - z * z + j1;
      y := 2 * x * y + j2;
      z := ya + j3;
      x := xa;
 {     xa := x;
      ya := y;
      za := z;
      Inc(bFirstIt);
      if (bFirstIt and 1) = 0 then
      begin
        x := x * x - y * y + J1;
        y := 2 * xa * y + J2;
    //    z := z + J3;
     end else begin
        x := x * x - z * z + J1;
//        y := y * y - z * z + J2;
    //    y := y + J2;
        z := 2 * xa * z + J3;
     end;    }
{    //other newton triplex
      xa := x;
      ya := y;
      za := z;
      x := x * x - 2 * y * z + J1;
      y := - z * z + 2 * xa * y + J2;
      z := ya * ya + 2 * xa * z + J3;

 {   //asdam slonofractal
      xa := x;
      ya := y;
      za := Abs(z);
      x := x * x - root2 * y * y + 2 * za * x + J1;
      y := 2 * xa * y + 2 * za * y + J2;
      z := z * z - root2 * ya * ya  + Abs(J3);   }
//    end;
   {   v1 := NormaliseVector(@x);
      SinCosD(ArcCos(v1[0]), SinPhi, CosPhi);
      q[0] := 0;
      q[1] := 0;
      q[2] := -v1[1] * SinPhi;
      q[3] := CosPhi;
      QuatRotate(@v1, q);
      InvertQuat(q);
      QuatRotate(@v1, q);
      x := Rout * v1[0] + J1;
      y := Rout * v1[1] + J2;
      z := Rout * v1[2] + J3;

{
      R := Power(Rout, 0.5 * PDouble(Integer(PVar) - 16)^);

      xa := R * cosPhi * cosTheta;
      ya := R * cosPhi * sinTheta;
      za := R * sinPhi * PDouble(Integer(PVar) - 48)^;

      x := xa + J1;
      y := ya + J2;
      z := za + J3;

    {  SinCosD(ph * PDouble(Integer(PVar) - 24)^, sinPhi, cosPhi);
      SinCosD(th * PDouble(Integer(PVar) - 24)^, sinTheta, cosTheta);

      R := Power(Rout, 0.5 * PDouble(Integer(PVar) - 16)^);
      x := R * cosPhi * cosTheta + J1;
      y := R * cosPhi * sinTheta + J2;
      z := R * sinPhi * PDouble(Integer(PVar) - 40)^ + J3; }

//    end;

//asm
  {   th := ArcTan2(y, x);
      ph := ArcTan2(z, Sqrt(Sqr(x) + Sqr(y)));   //  ArcSin(z / R);
      pp := Power(Rout, 0.5 * PDouble(Integer(PVar) - 16)^);
      SinCosD(PDouble(Integer(PVar) - 16)^ * ph, sinPhi, cosPhi);
      SinCosD(PDouble(Integer(PVar) - 16)^ * th, sinTheta, cosTheta);
      x := pp * cosPhi * cosTheta + J1;
      y := pp * cosPhi * sinTheta + J2;
      z := PDouble(Integer(PVar) - 24)^ * pp * sinPhi + J3;
    push esi  //TrifoxComplexAngles 'R intpow','Angle scale','Flip The-Phi (0,1)', 'Angle intpow','Norm R angle (0,1)','Norm fix','Z mul'
    push edi
//    add  esp, -8
    mov  esi, [ebp + 8]        //PIteration3D
    mov  edi, [esi + 48]

     fld1                //    Result := 1
     mov  eax, [edi - 12]  //  Int power
     fld  qword [esi + 56] //Rout
     fsqrt                 //R=base, Result
     jmp  @@2
@@1: fmul st, st            { X := Base * Base
@@2: shr  eax,1
     jnc  @@1
     fmul st(1), st    //B,R*B  { Result := Result * X
     jnz  @@1
     fstp st           //r'

    fldz
    fld1               //1,0,r
    fld  qword [edx - 8]
    fld  qword [edx]
    fld  qword [ecx]   //z,y,x,1,0,r
    fld  st(2)
    fmul st, st        //xx,z,y,x,1,0,r
    fld  st(2)
    fmul st, st        //yy,xx,z,y,x,1,0,r
    faddp
    fsqrt              //sqrt(xx+yy),z,y,x,1,0,r
    fpatan             //phi,y,x,1,0,r
    fxch st(2)         //x,y,phi,1,0,r
    fpatan             //theta,phi, 1,0,r
    fld  dword [edi - 16]
    fmul st(2), st
    fmulp
    cmp  dword [edi - 24], 0
    jz   @@3
    fxch
@@3:
    cmp  dword [edi - 32], 0
    jz   @@7           // reciprocal r angle
    fld  st(1)
    fmul st, st
    fld  st(1)
    fmul st, st
    faddp
    fadd dword [edi - 36]
  //  fsqrt
    fld1
    fdivrp
    fmul st(2), st
    fmulp
@@7:

     mov  eax, [edi - 28]  // int angle pow
     jmp  @@5
@@4: fld  st(1)        //by,bx,by,rx,ry   Base*Base:   st = st*st - st(1)*st(1);  st(1) = 2*st*st(1)
     fmul st, st(1)
     fadd st, st       //2bxby,bx,by,rx,ry
     fxch st(2)        //by,bx,2bxby,rx,ry
     fmul st, st
     fxch
     fmul st, st       //bxbx,byby,2bxby,rx,ry
     fsubrp            
@@5: shr  eax,1
     jnc  @@4
     fld  st(2)        //   R=R*Base:  st(2) = st(2)*st - st(3)*st(1);  st(3) = st(3)*st + st(2)*st(1)
     fmul st, st(1)    //rx*bx,bx,by,rx,ry
     fld  st(4)
     fmul st, st(3)    //ry*by,rx*bx,bx,by,rx,ry
     fsubp             //rx*bx-ry*by,bx,by,rx,ry
     fxch st(3)        //rx,bx,by,rx',ry
     fmul st, st(2)
     fld  st(1)        //bx,rx*by,bx,by,rx',ry
     fmulp st(5), st   //rx*by,bx,by,rx',ry*bx
     faddp st(4), st   //bx,by,rx',ry*bx+rx*by
     jnz  @@4
     fcompp            //theta',phi', r

{const s3: Single = 3;
asm                            //GenIntPower on Pixelpos: R1type on Px pos, R2type on Py pos
     push esi                  //variable int rotations 2-11    RotType: 0:x|y 1:x|z 2:y|z 3:xy|z 4:xz|y 5:yz|x
     push edi                  //Rpower,Rot1 pow,type, EnableRot2,Rot2 pow,type, EnableRot3, Rot3 pow,type,  Zmul  = 10 paras
     push ebx                  //  -12   -16      -20     -24       -28     -32       -36     -40     -44    -52(double)
     mov  esi, [ebp + 8]       //const: [edi] int64, int64 xor mask, double 1.0
     mov  edi, [esi + 48]
  //   movapd  xmm6, [edi]
     xorpd   xmm6, xmm6
     movhpd  xmm6, [edi + 80]
     add  esp, -16
     fld1
     fadd st, st
     fld  qword [esi + 16]  //Pz,2
     fabs
     fmul s3
     faddp
     fistp dword [esp]
     fld  qword [esi]      //Px
     fabs
     fadd st, st
     fistp dword [esp + 4]     //type 0..11
     fld  qword [esi + 8]      //Py
     fabs
     fadd st, st
     fistp dword [esp + 8]     //type 0..11


     movupd  xmm0, [eax]        //x,y    calc R
     movsd   xmm5, [ecx]
     mulpd   xmm0, xmm0
     mulsd   xmm5, xmm5
db   $66,$0F,$7C,$C0            //haddpd  xmm0, xmm0
     addsd   xmm5, xmm0
     movsd   xmm2, [edi + 32]   //1.0
     sqrtsd  xmm1, xmm5         //Rin, sqr(Rin)
     divsd   xmm2, xmm1         //1/Rin
     mov  edx, [esp]            //int     Rpower
     cmp  edx, 4
     jl   @2
     movsd   xmm3, xmm5
     mulsd   xmm5, xmm5         //r^4
     cmp  edx, 8
     jl   @1
     mulsd   xmm5, xmm5         //r^8
     cmp  edx, 10
     jl   @2
     jmp  @3
@1:  cmp  edx, 6
     jl   @2
@3:  mulsd   xmm5, xmm3         //*r
@2:  shr  edx, 1
     jnc  @up
     mulsd   xmm5, xmm1
@up:
     unpcklpd xmm2, xmm2
     movupd  xmm0, [eax]
     movsd   xmm1, [ecx]
     mulpd   xmm0, xmm2
     movsd   [eax + 8], xmm5
     mulsd   xmm1, xmm2         //norm input vec
     mov  edx, [esp]            //int rot1 pow
     mov  ebx, [esp + 4]        //int rot1 type
     call @rotate
     cmp  [edi - 24], 0
     jz   @@skipr2
     mov  edx, [esp]            //int rot2 pow
     mov  ebx, [esp + 8]        //int rot2 type
     call @rotate
@@skipr2:
     cmp  [edi - 36], 0
     jz   @@fin
     mov  edx, [edi - 40]       //int rot3 pow
     mov  ebx, [edi - 44]       //int rot3 type
     call @rotate
@@fin:
     mov  esi, [ebp + 8]
     movsd   xmm5, [eax + 8]
     movupd  xmm3, [esi + 24]   //J1,J2
     unpcklpd xmm5, xmm5
     mulsd   xmm1, xmm5
     mulpd   xmm0, xmm5         //scale output vec
     mulsd   xmm1, [edi - 52]
     addpd   xmm0, xmm3
     addsd   xmm1, [esi + 40]
     movupd  [eax], xmm0
     movsd   [ecx], xmm1
     add  esp, 16
     pop  ebx
     pop  edi
     pop  esi
     pop  ebp
     ret  8

@rotate:            //ecx = type  0:x|y  1:x|z  2:y|z  3:xy|z  4:xz|y  5:yz|x      call @CINTPOW  xmm0 + edx pow
     xor  esi, esi
     cmp  ebx, 6
     jl   @@ud
     add  esi, 1
     sub  ebx, 6
@@ud:
     cmp  ebx, 3
     jl   @2dr
     sub  ebx, 4
     jns  @u4
     movapd  xmm5, xmm0  //rottype 3    xy|z       xmm0 Lo = Rxy,  xmm0 Hi = z
     mulpd   xmm0, xmm0
db   $66,$0F,$7C,$C0     //haddpd  xmm0, xmm0  $C0 + $38 + $07 first xmm reg + second xmm reg 0-7
     sqrtsd  xmm0, xmm0  //Rxy
     movsd   [ecx], xmm0
     unpcklpd xmm0, xmm1 //xmm1 Lo to xmm0 Hi -> Rxy,z
     call @CINTPOW
     movapd  xmm1, xmm0  //Rxy',z'
     divsd   xmm0, [ecx] //Rxy'/Rxy  change of x,y
     unpcklpd xmm0, xmm0
     unpckhpd xmm1, xmm1 //z back to xmm1 Lo
     mulpd   xmm0, xmm5  //scale x,y  by Rxy'/Rxy
     ret
@u4:    //rottype 4    xz|y
     sub  ebx, 1
     jns  @u5
     movhpd  [eax], xmm0 //y    rottype 4    xz|y
     unpcklpd xmm0, xmm1 //x,z
     movapd  xmm5, xmm0
     mulpd   xmm0, xmm0
db   $66,$0F,$7C,$C0     //haddpd  xmm0, xmm0  $C0 + $38 + $07 first xmm reg + second xmm reg 0-7
     sqrtsd  xmm0, xmm0  //Rxz
     movsd   [ecx], xmm0
     movhpd  xmm0, [eax] //xmm1 Lo to xmm0 Hi -> Rxz,y
     call @CINTPOW
     movapd  xmm1, xmm0  //Rxz',y'
     divsd   xmm0, [ecx] //Rxz'/Rxz
     unpcklpd xmm0, xmm0
     mulpd   xmm0, xmm5  //scale x,z
     unpckhpd xmm1, xmm0 //y,z
     unpcklpd xmm0, xmm1 //x',y'
     unpckhpd xmm1, xmm1 //z
     ret
@u5:    //rottype 5    yz|x
     movsd   [eax], xmm0 //x
     unpcklpd xmm1, xmm1
     unpckhpd xmm0, xmm1 //y,z
     movapd  xmm5, xmm0
     mulpd   xmm0, xmm0
db   $66,$0F,$7C,$C0     //haddpd  xmm0, xmm0  $C0 + $38 + $07 first xmm reg + second xmm reg 0-7
     sqrtsd  xmm0, xmm0  //Ryz
     movsd   [ecx], xmm0
     movhpd  xmm0, [eax] //xmm1 Lo to xmm0 Hi -> Ryz,x
     call @CINTPOW
     movapd  xmm1, xmm0  //Ryz',x'
     divsd   xmm1, [ecx] //Ryz'/Ryz
     unpcklpd xmm1, xmm1
     mulpd   xmm1, xmm5  //scale y,z
     unpckhpd xmm0, xmm0 //x,x
     unpcklpd xmm0, xmm1 //x,y
     unpckhpd xmm1, xmm1 //z
     ret
@2dr:   //norm 2d vec: 0:x|y 1:x|z 2:y|z  to 1 and call pow   xmm5=xmm5/(R3d*Rvec2d)  vec3d=vec3d/Rvec2d   R3d=xmm2
     sub  ebx, 1
     jns  @u1
     movapd  xmm3, xmm0   //rottype 0  x|y
     mulpd   xmm3, xmm3
db   $66,$0F,$7C,$DB      //haddpd  xmm3, xmm3  $C0 + $38 + $07 first xmm reg + second xmm reg 0-7
     sqrtsd  xmm5, xmm3   //Rxy
     movsd   xmm4, [edi + 32]    //1.0
     divsd   xmm4, xmm5   //1/Rvec2D
     unpcklpd xmm4, xmm4
     unpcklpd xmm5, xmm5
     movsd   [ecx], xmm1  //save Z
     mulpd   xmm0, xmm4   //norm xy
     call @CINTPOW
     movsd   xmm1, [ecx]
     mulpd   xmm0, xmm5   //scale back to vec3 norm
     ret
@u1: sub  ebx, 1
     jns  @u2
     movhpd  [ecx], xmm0  //y     rottype 1   x|z
     unpcklpd xmm0, xmm1  //x,z
     movapd  xmm3, xmm0
     mulpd   xmm3, xmm3
db   $66,$0F,$7C,$DB      //haddpd  xmm3, xmm3
     sqrtsd  xmm5, xmm3   //Rxz
     movsd   xmm4, [edi + 32]    //1.0
     divsd   xmm4, xmm5   //1/Rvec2D
     unpcklpd xmm4, xmm4
     unpcklpd xmm5, xmm5
     mulpd   xmm0, xmm4   //norm xz
     call @CINTPOW
     mulpd   xmm0, xmm5   //scale back x,z
     pshufd  xmm1, xmm0, $4E   //z
     movhpd  xmm0, [ecx]  //x,y
     ret
@u2:   // rottype 2   y|z
     movsd   [ecx], xmm0  //x
     unpckhpd xmm0, xmm0  //y,y
     unpcklpd xmm0, xmm1  //y,z
     movapd  xmm3, xmm0
     mulpd   xmm3, xmm3
db   $66,$0F,$7C,$DB      //haddpd  xmm3, xmm3
     sqrtsd  xmm5, xmm3   //Ryz
     movsd   xmm4, [edi + 32]    //1.0   +16 in m3f!
     divsd   xmm4, xmm5   //1/Rvec2D
     unpcklpd xmm4, xmm4
     unpcklpd xmm5, xmm5
     mulpd   xmm0, xmm4   //norm yz
     call @CINTPOW
     mulpd   xmm0, xmm5   //scale back y,z
     pshufd  xmm1, xmm0, $4E   //z
     unpcklpd xmm0, xmm0  //y,y
     movlpd  xmm0, [ecx]  //x,y
     ret

@CINTPOW:  //comlex power of xmm0, edx contains exponent   new option: flip x|y
     cmp  esi, 0
     jz  @@u1
     shufpd  xmm0, xmm0, 1
@@u1:
     movapd  xmm1, xmm0
     call @CMUL
     cmp  edx, 2
     jle  @@ex
     movapd  xmm3, xmm1          //z
     cmp  edx, 4
     jl   @@2
     movapd  xmm4, xmm0          //z
     movapd  xmm1, xmm0
     call @CMUL                  //z^4
     cmp  edx, 8
     jl   @@1
     movapd  xmm1, xmm0
     call @CMUL                  //z^8
     cmp  edx, 10
     jl   @@2
     jmp  @@3
@@1: //<8
     cmp  edx, 6
     jl   @@2
@@3:
     movapd  xmm1, xmm4
     call @CMUL
@@2: //<4
     shr  edx, 1
     jnc  @@ex
     movapd  xmm1, xmm3
     call @CMUL
@@ex:
     cmp  esi, 0
     jz  @@u2
     shufpd  xmm0, xmm0, 1
@@u2:
     ret
@CMUL:           // xmm0 * xmm1 = xmm0 (x1,y1)*(x2,y2)=(x,y) (real=lo,imag=hi) xmm1 stays intact for further multiplications
     pshufd  xmm2, xmm0, $4E     //y1,x1
     mulpd   xmm0, xmm1          //x1*x2,y1*y2
     mulpd   xmm2, xmm1          //y1*x2,x1*y2
     xorpd   xmm0, xmm6          //x1*x2,-y1*y2
db   $66,$0F,$7C,$C2 //haddpd xmm0, xmm2 //x1*x2-y1*y2,y1*x2+x1*y2  SSE3   $C0 + $38 + $07 first xmm reg + second xmm reg 0-7
     ret


     //Aexion HeartBox
   {   x := abs(x+PDouble(Integer(PVar) - 40)^) - abs(x-PDouble(Integer(PVar) - 40)^) - x;
      y := abs(y+PDouble(Integer(PVar) - 40)^) - abs(y-PDouble(Integer(PVar) - 40)^) - y;
      z := abs(z+PDouble(Integer(PVar) - 40)^) - abs(z-PDouble(Integer(PVar) - 40)^) - z;
      xx := x*x;
      yy := y*y;
      zz := z*z;
      aa := 2*xx + yy + zz - 1;
      h := (aa*aa*aa - 0.1 * xx * zz * z - yy * zz * z) * PDouble(Integer(PVar) - 48)^; //0.0005
      r := Sqrt((xx + yy + zz) * h); //-sqrt(r*h);//reverse it
      if r < PDouble(Integer(PVar) - 32)^ then r := PDouble(Integer(PVar) - 24)^ else
      if r < 1 then r := PDouble(Integer(PVar) - 16)^ / r
               else r := PDouble(Integer(PVar) - 16)^;
      x := r * x + J1;
      y := r * y + J2;
      z := r * z + J3;
      w := r * w;

   //David new complex:
 {   //  r := x*x + y*y + z*z + w*w;
      cxy[0] := x;
      cxy[1] := y;
      czw[0] := z;
      czw[1] := w;
      cccs := ComplexPower(CConj(ComplexAdd(ComplexSqr2(cxy), ComplexSqr2(czw))), complex1dsqrt);
      ccsn := ComplexMul(czw, cccs);
      cccs := ComplexMul(cxy, cccs);
      cxy := ComplexScale(ComplexSub(Complexsqr2(cccs), ComplexSqr2(ccsn)), Rout);
      czw := ComplexScale(ComplexMul(cccs, ccsn), 2 * Rout);
      x := cxy[0] + J1;
      y := PDouble(Integer(PVar) - 16)^ * cxy[1] + J2;
      z := PDouble(Integer(PVar) - 24)^ * czw[0] + J3;
      w := czw[1] + J4;

         //knighty smoothbox
  {   x := Sqrt(PDouble(Integer(PVar) - 24)^ + Sqr(x + 1)) - Sqrt(PDouble(Integer(PVar) - 24)^ + Sqr(x - 1)) - x;
      y := Sqrt(PDouble(Integer(PVar) - 24)^ + Sqr(y + 1)) - Sqrt(PDouble(Integer(PVar) - 24)^ + Sqr(y - 1)) - y;
      z := Sqrt(PDouble(Integer(PVar) - 24)^ + Sqr(z + 1)) - Sqrt(PDouble(Integer(PVar) - 24)^ + Sqr(z - 1)) - z;
      r := Sqrt(x*x + y*y + z*z + 1e-80);
      k := 3 * r - 2;
      r := PDouble(Integer(PVar) - 16)^ * ((k*k*k - k + 6) ) / ((k*k + 1) + (r * 0.7 / (r + 1)) ) / (3 * r);
      x := r * x + J1;
      y := r * y + J2;
      z := r * z + J3;
      w := w * (Abs(r) * 0.9 + 0.2);  

    {  if bFirstIt = 0 then  //Aexion chrystalbox
      begin
        Inc(bFirstIt);
        x := abs(J3) - PDouble(Integer(PVar) - 32)^;
        y := abs(0.86602540378443864676372317075294*J1-0.5*J3) - PDouble(Integer(PVar) - 32)^;
        z := abs(-0.86602540378443864676372317075294*J1-0.5*J3) - PDouble(Integer(PVar) - 32)^;
        w := abs(J2) - PDouble(Integer(PVar) - 32)^;
        J1 := x;
        J2 := y;
        J3 := z;
        J4 := w;
        x := 0;
        y := 0;
        z := 0;
        w := 0;
      end;
      x := abs(x+PDouble(Integer(PVar) - 24)^) - abs(x-PDouble(Integer(PVar) - 24)^) - x;
      y := abs(y+PDouble(Integer(PVar) - 24)^) - abs(y-PDouble(Integer(PVar) - 24)^) - y;
      z := abs(z+PDouble(Integer(PVar) - 24)^) - abs(z-PDouble(Integer(PVar) - 24)^) - z;
      w := abs(w+PDouble(Integer(PVar) - 24)^) - abs(w-PDouble(Integer(PVar) - 24)^) - w;
      vm := abs(x) + abs(y) + abs(z) + abs(w); //sqrt(x*x+y*y+z*z+w*w);
      if (vm < 0.05) then
      begin
        x := x*4;
        y := y*4;
        z := z*4;
        w := w*4;
      end         //1.5
      else if (vm < 1) then
      begin
        vsq := 1 / vm*vm*vm;
        x := x * vsq;
        y := y * vsq;
        z := z * vsq;
        w := w * vsq;
      end;
      x := PDouble(Integer(PVar) - 16)^ * x + J1;
      y := PDouble(Integer(PVar) - 16)^ * y + J2;
      z := PDouble(Integer(PVar) - 16)^ * z + J3;
      w := PDouble(Integer(PVar) - 16)^ * w + J4;
      Deriv1 := Deriv1 * PDouble(Integer(PVar) - 16)^;  }

 {//  nHybrid:    array[0..5] of Integer;  //+76    conditional ItCounts
      if PInteger(Integer(PVar) - 56)^ = 0 then
        r := PDouble(Integer(PVar) - 16)^ * x + PDouble(Integer(PVar) - 24)^ * y +
             PDouble(Integer(PVar) - 32)^ * z + PDouble(Integer(PVar) - 40)^
      else
        r := PDouble(Integer(PVar) - 16)^ * C1 + PDouble(Integer(PVar) - 24)^ * C2 +
             PDouble(Integer(PVar) - 32)^ * C3 + PDouble(Integer(PVar) - 40)^;

      i2 := PInteger(Integer(PVar) - 52)^;
      if i2 < 0 then i2 := 0 else
      if i2 > 99999 then i2 := 99999;
      i3 := 0;
      if r < 0 then
      begin
        i3 := i2;
        i2 := 0;
      end;
      i := PInteger(Integer(PVar) - 44)^;
      if i < 1 then i := 1 else
      if i > 6 then i := 6;
      if PInteger(Integer(PIteration3D) + 72 + i shl 2)^ < 0 then
        PInteger(Integer(PIteration3D) + 72 + i shl 2)^ := i2 or $80000000
      else
        PInteger(Integer(PIteration3D) + 72 + i shl 2)^ := i2;
      i := PInteger(Integer(PVar) - 48)^;
      if i < 1 then i := 1 else
      if i > 6 then i := 6;
      if PInteger(Integer(PIteration3D) + 72 + i shl 2)^ < 0 then
        PInteger(Integer(PIteration3D) + 72 + i shl 2)^ := i3 or $80000000
      else
        PInteger(Integer(PIteration3D) + 72 + i shl 2)^ := i3;   }

//Its a 4th power lambdabulb with a seed of 1.0625 + i*0.2375 with shadows. The function is z = c*(z-z^p)
   {   if bFirstIt = 0 then
      begin
        Inc(bFirstIt);
        Dfree1 := Sqrt(J1*J1 + J2*J2 + J3*J3);
        if Dfree1 < 1e-60 then Dfree2 := 0 else
        Dfree2 := ArcSin(J3 / Dfree1);
        Deriv2 := ArcTan2(J2, J1);
      end;

      r := Sqrt(Rout);
      ph := ArcTan2(y, x) * PDouble(Integer(PVar) - 16)^;
      th := ArcSin(z / r) * PDouble(Integer(PVar) - 16)^;
      r1 := Power(r, PDouble(Integer(PVar) - 16)^);
      SinCosD(ph, Sx, Cx);
      SinCosD(th, Sy, Cy);
      xa := x - (Cx * Cy * r1);
      ya := y - (Sx * Cy * r1);
      za := z - (Sy * r1);

      r1 := Sqrt(xa*xa + ya*ya + za*za);
      ph := ArcTan2(ya, xa) + Deriv2;
      th := ArcSin(za / r1) + Dfree2;  //+
      r := r1 * Dfree1;
      SinCosD(ph, Sx, Cx);
      SinCosD(th, Sy, Cy);
      x := Cx * Cy * r;
      y := Sx * Cy * r;
      z := Sy * r;  }

{
m := 1/Sqrt(x*x + y*y);  //normalize vec(x,y)
x := x*m;
y := y*m;
z := z*m;
ipow2(x,y);     //rotate vec(x,y), radius=1 is unchanged

m := 1/Sqrt(x*x + y*y + z*z);  //normalize vec(x,y,z)
x := x*m;
y := y*m;
z := z*m;
m := Sqrt(x*x + y*y);    //length of vec(x,y)
mt := m;
ipow2(m,z);     //rotate vec(z,|vec(x,y)|)

m := m/mt*R;
x := x * m + J1;
y := y * m + J2;
z := z * R + J3;  }


 {  r := Sqrt(Rout);
   r1 := PDouble(Integer(PVar) - 16)^ * r / Sqrt(Sqr(x) + Sqr(y) + 1e-40);        //infpoles
   phi := r1 * ArcSin(z / r);
   theta := r1 * ArcTan2(y, x);
   SinCosD(phi, Sx, Cx);
   SinCosD(theta, Sz, Cz);
   r := Power(r, r1);
   x := r * Cz * Cx + J1;
   y := r * Sz * Cx + J2;
   z := r * Sx * PDouble(Integer(PVar) - 24)^ + J3;

   //Menger4d
{   x := abs(x);
   y := abs(y);
   z := abs(z);
   w := abs(w);
   if x<y then begin r:=x; x:=y; y:=r; end;
   if x<z then begin r:=x; x:=z; z:=r; end;
   if x<w then begin r:=x; x:=w; w:=r; end;
   if y<z then begin r:=y; y:=z; z:=r; end;
   if y<w then begin r:=y; y:=w; w:=r; end;
   if z<w then begin r:=z; z:=w; w:=r; end;
   //rotate4d
   Rotate4D(@x, TPSMatrix4(Integer(PVar) - 88));
   r := PDouble(Integer(PVar) - 16)^;
   Deriv1 := Deriv1 * r;
   x := x*r - (r-1);
   y := y*r - (r-1);
   w := w*r + PDouble(Integer(PVar) - 24)^;
   r1 := 0.5*(r-1)/r;
   z := (-abs(z - r1) + r1) * r;  }

   {   R  := Sqrt(Rout);        //FloatP with derivatives
      th := ArcTan2(y, x);
      ph := ArcSin(z / R);
      pp := Power(R, PDouble(Integer(PVar) - 16)^);

      if bFirstIt = 0 then
      begin
        bFirstIt := 1;        // derivatives
        thd := 0;
        phd := 0;
        ppd := 1;
      end else begin
        thd := ArcTan2(Deriv2, Deriv1);    // derivatives
        phd := ArcSin(Deriv3 / RoutDeriv);
        ppd := Power(R, PDouble(Integer(PVar) - 16)^ - 1);
      end;
      SinCosD(phd + (PDouble(Integer(PVar) - 16)^ - 1) * ph, Sx, Cx);
      SinCosD(thd + (PDouble(Integer(PVar) - 16)^ - 1) * th, Sy, Cy);
      R2 := PDouble(Integer(PVar) - 16)^ * Power(R, PDouble(Integer(PVar) - 16)^ - 1) * RoutDeriv;
      Deriv1 := R2 * Cx * Cy + 1;
      Deriv2 := R2 * Cx * Sy;
      Deriv3 := R2 * Sx;
      RoutDeriv := Sqrt(Deriv1 * Deriv1 + Deriv2 * Deriv2 + Deriv3 * Deriv3);

      SinCosD(PDouble(Integer(PVar) - 16)^ * ph, Sx, Cx);
      SinCosD(PDouble(Integer(PVar) - 16)^ * th, Sy, Cy);
      x := pp * Cx * Cy + J1;
      y := pp * Cx * Sy + J2;
      z := PDouble(Integer(PVar) - 24)^ * pp * Sx + J3;   }



{var ph, th, pp, r1, Sx, Cx, Sy, Cy: Double;
    pb: PByteArray;
    pd: PDouble;
begin
    with TPIteration3Dext(Integer(PIteration3D) - 56)^ do
    begin                                //Aexion rotate c   [Power, Z mul, Enable RotC (0,1), Cond Phi (0,1), Power C, Cz mul, Mod (0,1)]
      pb := Pointer(Integer(PVar) - 56);             ATth(1,2)  ATph(3,4)
      pd := @pb[56-16];                   Modus:  0:  J1|J3,J2      J3,J1           mod and 1 ->
      r1 := x*x + y*y + z*z;                      1:  J1|J2,J3      J2,J1    xch 2<>3
      th := ArcTan2D(Sqrt(x*x + z*z), y) * pd^;   2:  J2|J3,J1      J3,J2    xch 1<>2
      ph := ArcTan2D(z, x) * pd^;                 3:  J1|J3,J2      J3,J1   diffs
      SinCosD(ph, Sx, Cx);                        4:  J1|J2,J3      J2,J1    xch 2<>3
      SinCosD(th, Sy, Cy);                        5:  J2|J3,J1      J3,J2    xch 1<>2
      r1 := Power(r1, pd^ * 0.5);
      x := Cy * Cx * r1 + J1;
      y := Cy * Sx * r1 + J2;
      z := r1 * Sy * PDouble(@pb[56-24])^ + J3;
      if pb[56-28] <> 0 then  //rotate c
      begin
        if pb[56-52] <> 0 then
        begin
          pp := LengthOfVec(SubtractVectors(TPVec3D(@x), TPVec3D(@J1)^));
          pd := @pp;
        end
        else pd := @pb[56-40];
        r1 := Sqrt(J1*J1 + J2*J2 + J3*J3);
        if pb[56-56] = 1 then
        begin
          th := ArcTan2D(Sqrt(Sqr(x - J1) + Sqr(z - J3)), y - J2) * pd^;
          ph := ArcTan2D(z - J3, x - J1) * pd^;
        end else begin
          th := ArcTan2D(Sqrt(J1*J1 + J3*J3), J2) * pd^;
          ph := ArcTan2D(J3, J1) * pd^;
        end;
        if (pb[56-32] <> 0) and (x > 0) then ph := -ph; // conditional  phi1 := (x>0)?atan2(cz,cx)*8:-atan2(cz,cx)*8;
        SinCosD(ph, Sx, Cx);            // ph := ph xor ((UserInCond and 1) shl 31) and x) xor $80000000;
        SinCosD(th, Sy, Cy);
        J1 := Cy * Cx * r1;
        J2 := Cy * Sx * r1;
        J3 := r1 * Sy * PDouble(@pb[56-48])^;
      end;
    end; }
    
    

 // STORAGE //

  {   testhybridDEoption: Integer = 2; //6;  //11=ABox  5=4dABox  6=4dIFS
    testhybridRstop: Double = 1024;    //1024
    testhybridDEscale: Double = 0.2;   //0.2;
    testhybridPow: Double = 2;            //0,7,0    21: .SRECI2 single + reciproc single
    testhybridOptionCount: Integer = 14;   //AmazingBox vars: scale=double, MinR=boxscale: Scale/Sqr(MinR), Sqr(MinR), Fold=double..
    testhybridOptionTypes: array[0..13] of Integer = (1,1,9,1,1,1,1,1,1,6,6,6,1,1);  //5:.3DoubleAngles  9:DSquare
    testhybridOptionVals: array[0..13] of Double = (2,0.25,0.5,2,2,2,1,1,1,0,0,0,2,2);
    testhybridOptionsStrings: array[0..13] of String = ('Scale','BoxFold','SphereFold','NonLin X','NonLin Y','NonLin Z','Lin X','Lin Y',
      'Lin Z','Rotate X','Rotate Y','Rotate Z', 'NonLin vary', 'Lin vary'); }
{.Double Scale = 1.5      asurf
.Boxscale Min R = 0.5
.Double Fold = 1
.3SingleAngles Rotation1 = 5
.Double Scale vary = 0
.Integer Sphere or Cylinder = 1   }
 {   testhybridDEoption: Integer = 2;  //abox platinum
    testhybridRstop: Double = 1024;
    testhybridDEscale: Double = 0.2;
    testhybridPow: Double = 2;            //0,7,0    21: .SRECI2 single + reciproc single
    testhybridOptionCount: Integer = 15;   //AmazingBox vars: scale=double, MinR=boxscale: Scale/Sqr(MinR), Sqr(MinR), Fold=double..
    testhybridOptionTypes: array[0..14] of Integer = (0,7,0,6,6,6,0,0,0,13,3,3,3,3,2);  //6:.3SingleAngles  9:DSquare
    testhybridOptionVals: array[0..14] of Double = (2,0.5,1,0,0,0,0,0,0,1,0,0,0,0,0);
    testhybridOptionsStrings: array[0..14] of String = ('Scale','Min R/IR','Fold','RotationX','RotationY','RotationZ',
      'Inv xC','Inv yC','Inv zC','Inv Radius','FoldX, XY angle','FoldX, XZ angle','FoldY, XY angle','FoldY, YZ angle',
      'Abs XYZ switches');   }

{.Double Scale = 2
.Boxscale MinR/IR = 0.5
.Double Fold = 1
.3SingleAngles Rotate = 0
.Double Inv xC = 0
.Double Inv yC = 0
.Double Inv zC = 0
.DRecipro Inv Radius = 1
.DoubleAngle FoldX, XY angle = 0
.DoubleAngle FoldX, XZ angle = 0
.DoubleAngle FoldY, XY angle = 0
.DoubleAngle FoldY, YZ angle = 0
.Integer Abs XYZ switches = 0 }{   testhybridDEoption: Integer = 11;  //amazing surf
    testhybridRstop: Double = 20;
    testhybridDEscale: Double = 0.2;
    testhybridPow: Double = 2;            //0,7,0    21: .SRECI2 single + reciproc single
    testhybridOptionCount: Integer = 8;   //AmazingBox vars: scale=double, MinR=boxscale: Scale/Sqr(MinR), Sqr(MinR), Fold=double..
    testhybridOptionTypes: array[0..7] of Integer = (0,7,0,6,6,6,0,2);  //6:.3SingleAngles  9:DSquare
    testhybridOptionVals: array[0..7] of Double = (1.5,0.5,1,5,5,5,0,1);
    testhybridOptionsStrings: array[0..7] of String = ('Scale','Min R','Fold','Roatation','','','Scale vary','Sphere or Cylinder');
{    testhybridDEoption: Integer = 11;   //smoothbox
    testhybridRstop: Double = 1024;    //1024
    testhybridDEscale: Double = 0.2;   //0.2;
    testhybridPow: Double = 2;            //0,7,0    21: .SRECI2 single + reciproc single
    testhybridOptionCount: Integer = 8;   //AmazingBox vars: scale=double, MinR=boxscale: Scale/Sqr(MinR), Sqr(MinR), Fold=double..
    testhybridOptionTypes: array[0..7] of Integer = (0,7,0,0,2,0,2,0);  //5:.3DoubleAngles  9:DSquare
    testhybridOptionVals: array[0..7] of Double = (2,0.5,1,0,6,1,4,0.3);
    testhybridOptionsStrings: array[0..7] of String = ('Scale','Min R','Fold','Scale vary','Sharpness (Integer 2+)',
      'Fix (BoxFold)','Sh. of BallFold (Int 3+)','Fix (BallFold)');     }
{       testIFSDEoption: Integer = 20;
       testIFSOptionCount: Integer = 13;  //Sphere
       testIFSOptionTypes: array [0..12] of Integer = (0,14,14,0,14,13,13,13,2,2,1,1,0);   //.3SingleAngles = 6  .2Doubles = 14  .Integer = 2
       testIFSOptionVals: array [0..12] of Double = (1,2,0,0,3,1,1,1,1,0,1,1,0);  // .SINGLEANGLE = 4 (sin,cos)  .DSqrReci = 15
       testIFSOptionsStrings: array [0..12] of String = ('Radius','Scale','Z add','Y add','X add',  //.DRECIPRO = 13
         'Z size','Y size','X size','Apply add+scale','Otrap option','Otrap offset','Otrap scale',
         'Inside radius'); // }
   {    testIFSDEoption: Integer = 20;
       testIFSOptionCount: Integer = 9;  //Box rounded
       testIFSOptionTypes: array [0..8] of Integer = (0,0,0,14,14,0,0,14,2);   //.3SingleAngles = 6  .2Doubles = 14  .Integer = 2
       testIFSOptionVals: array [0..8] of Double = (1,1,1,2,0,1,1,0.1,1);  // .SINGLEANGLE = 4 (sin,cos)  .DSqrReci = 15
       testIFSOptionsStrings: array [0..8] of String = ('Z halfwidth','Y halfwidth','X halfwidth',
         'Scale','Z add','Y add','X add','Border','Apply add+scale'); // }
      { testIFSDEoption: Integer = 20;
       testIFSOptionCount: Integer =14;  //sphere map
       testIFSOptionTypes: array [0..13] of Integer = (2,2,1,1,1,1,1,1,6,6,6,2,1,1);   //4=SINGLEANGLE    1=single
       testIFSOptionVals: array [0..13] of Single = (10,0,0,0,0,1,1,0.35,0,0,0,1,0,1);
       testIFSOptionsStrings: array [0..13] of String =      //spheremap/Heightmap: col-nr position changed!
       ('Map nr', 'Col nr', 'Xoffset', 'Yoffset', 'Zoffset', 'Xscale', 'Yscale', 'Hscale',
       'Rotation', 'Rotation', 'Rotation', 'OTrap Color nr', 'Color offset', 'Color mult');  }
     {   testIFSDEoption: Integer = 20;
       testIFSOptionCount: Integer = 15;  //HeightMapSphere with OTrap
       testIFSOptionTypes: array [0..14] of Integer = (2,2,1,1,1,1,1,1,18,1,1,1,2,1,1);
       testIFSOptionVals: array [0..14] of Single = (10,0,0,0,0,1,1,0.35,1,0,0,0,1,0,1);
       testIFSOptionsStrings: array [0..14] of String = ('Map nr', 'Map channel', 'X off',
       'Y off', 'Z off', 'Length', 'Radius', 'Map height', 'Scale', 'X rot', 'Y rot', 'Z rot'
       , 'OTrap channel','OTrap offset', 'OTrap mul');    }

{function ArcSin(const X : Double) : Double; overload;
asm
  //Result := ArcTan2(X, Sqrt((1+X) * (1-X)))
  FLD   X              x
  FLD1                 1,x
  FADD  ST(0), ST(1)   1+x,x
  FLD1                 1,1+x,x
  FSUB  ST(0), ST(2)   1-x,1+x,x
  FMULP ST(1), ST(0)   (1-x)*(1+x),x
  FSQRT
  FPATAN
end;}
{  fld1                 1
  fld    X              x,1
  fst    st(2)          x,1,x
  fmul   st(0), st(0)   xx,1,x
  fsubp                 1-xx
  fsqrt
  fpatan}

{  fldln2   power function
  fxch
  fyl2x
  fxch
  fmulp
  fldl2e
  fmulp
  fld    st(0)
  frndint
  fsub   st(1), st(0)
  fxch
  f2xm1
  fld1
  faddp
  fscale
  fstp   st(1)
}
      //x:eax,y:edx,z:ecx,w:esp->ebp+12, PIt:ebp+8
{procedure HybridCustomRiemann(var x, y, z, w: Double; PIteration3D: TPIteration3D);
asm
  push   esi
  push   edi
  mov    esi, [ebp + 8]     //PIteration3D       //Riemann
  mov    edi, [esi + 48]
  fld    qword [eax]
  fld    qword [edx]
  fld    qword [ecx]
  fld    qword [esi + 56]   //Rout,z,y,x
  fsqrt
  fld1                      //1,sqrt(Rout),z,y,x
  fdivrp                    //1/sqrt(Rout),z,y,x
  fmul   st(3), st(0)
  fmul   st(2), st(0)
  fmulp                     //z,y,x  *rx
  fld1                      //1,z,y,x
  fsub   st(2), st(0)       //1,z,y-1,x
  fdivr  st(2), st(0)       //1,z,1/(y-1),x
  fxch   st(2)              //1/(y-1),z,1,x
  fmul   st(3), st(0)
  fmulp                     //z/(y-1),1,x/(y-1) =rz,1,rx
  fld    st(2)              //rx,rz,1,rx
  fmul   st(0), st(3)       //rxrx,rz,1,rx
  fsub   st(0), st(2)       //rxrx-1,rz,1,rx
  fxch                      //rz,rxrx-1,1,rx
  fxch   st(3)              //rx,rxrx-1,1,rz
  fadd   st(0), st(0)       //2rx,rxrx-1,1,rz
  fxch
  fpatan                    //atx,1,rz              arctan(st1/st0)  arctan2(y,x)  (2rx,rxrx-1)
  fld    st(2)              //rz,atx,1,rz
  fmul   st(0), st(3)
  fsub   st(0), st(2)       //rzrz-1,atx,1,rz
  fxch                      //atx,rzrz-1,1,rz
  fxch   st(3)              //rz,rzrz-1,1,atx
  fadd   st(0), st(0)       //2rz,rzrz-1,1,atx
  fxch
  fpatan                    //atz,1,atx
  fld    qword [edi - 16]   //p,atz,1,atx
  fmul   st(3), st(0)       //p,atz,1,p*atx
  fmulp                     //p*atz,1,p*atx
  fsincos                   //cosz,sinz,1,patx
  fadd   st(0), st(2)       //cosz+1,sinz,1,patx
  fdivp                     //rz,1,patx
  fxch   st(2)              //patx,1,rz
  fsincos                   //cosx,sinx,1,rz
  fadd   st(0), st(2)       //cosx+1,sinx,1,rz
  fdivp                     //rx,1,rz
  fld    st(0)              //rx,rx,1,rz
  fmul   st(0), st(1)       //rxrx,rx,1,rz
  fld    st(3)              //rz,rxrx,rx,1,rz
  fmul   st(0), st(4)
  faddp                     //rzrz+rxrx,rx,1,rz
  fld    st(0)              //rzrz+rxrx,rzrz+rxrx,rx,1,rz
  fadd   st(0), st(3)       //rzrz+rxrx+1,rzrz+rxrx,rx,1,rz
  fdivr  st(0), st(3)       //1/rzx1,rzx,rx,1,rz
  fxch                      //rzx,05c,rx,1,rz
  fsubrp st(3), st(0)       //05c,rx,rzx-1,rz
  fmul   st(3), st(0)       //05c,rx,rzx-1,rz*05c
  fmul   st(2), st(0)
  fmulp                     //05a,b,05c
  fld    qword [edi - 16]   //p,05a,b,05c
  fmul   qword [edi - 8]    //05p,05a,b,05c
  fld    qword [esi + 56]   //rout,05p,05a,b,05c

  fldln2                    //ln2,rout,05p,05a,b,05c    power function
  fxch
  fyl2x
  fxch
  fmulp
  fldl2e
  fmulp
  fld    st(0)
  frndint
  fsub   st(1), st(0)
  fxch
  f2xm1
  fld1
  faddp
  fscale
  fstp   st(1)

  fmul   st(3), st(0)       //pow(rout),05a,b,05c
  fmul   st(2), st(0)
  fmulp                     //05a,b,05c
  fadd   st(0), st(0)
  fadd   qword [esi + 24]
  fstp   qword [eax]        //2b,c
  fadd   qword [esi + 32]
  fstp   qword [edx]
  fadd   st(0), st(0)
  fadd   qword [esi + 40]
  fstp   qword [ecx]
  pop    edi
  pop    esi
end;   }
                     //x:eax,y:edx,z:ecx,w:esp->ebp+12, PIt:ebp+8
{procedure HybridCustomPas(var x, y, z, w: Double; PIteration3D: TPIteration3D);
var i: Integer;
    psi, psi2, cs, sn, a, xt, yt, zt: Double;
begin
    with PIteration3D^ do
    begin
      i  := Integer(PVar);
      asm
        fld qword [edi]
        fld qword [esi]
        fpatan
        fstp qword [ebp - $10]
      end;                                                           //  0    +8  +16 +24 +32
      psi  := psi + PDouble(i + 32)^;  //msltoe  Vars: Pi/8, Pi/4, 1,  2, 2*Pi
      psi2 := 0;
      while (psi > PDouble(i)^) do
      begin
        psi  := psi - PDouble(i + 8)^;
        psi2 := psi2 - PDouble(i + 8)^;
      end;
      asm
        fld qword [ebp - $18]
        fsincos
        fstp qword [ebp - $20]
        fstp qword [ebp - $28]
      end;
   //   cs := Cos(psi2);
   //   sn := Sin(psi2);
      yt := y*cs - z*sn;
      zt := y*sn + z*cs;
      y  := yt;
      z  := zt;
      a  := PDouble(i + 16)^ - z*z / (x*x + y*y + z*z);
      xt := (x*x - y*y) * a;
      yt := PDouble(i + 24)^ *x*y * a;
      zt := PDouble(i + 24)^ *z*Sqrt(x*x + y*y);
      x  := xt + J1;
      y  := yt*cs + zt*sn + J2;
      z  := zt*cs - yt*sn + J3;
    end;
end;

{function ArcTan2D(Y, X: Double): Double;
asm
    FLD     Y
    FLD     X
    FPATAN
    FWAIT
end;  }